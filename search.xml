<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[设计模式的js实现(2)--装饰器模式]]></title>
      <url>/2019/09/23/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84js%E5%AE%9E%E7%8E%B0(2)--%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>上一篇中我们提到了装饰器模式，这也是一种非常实用的设计模式，主要的特点是非侵入式，能让组件功能能被更好的解耦和复用，解决了不同组件之间共享某些相同功能的难题。有时候我们并不关心函数的内部实现，仅仅想做功能增强，装饰器模式就能给我们带来良好的可读性的同时，减少我们修改需求的成本。</p>
<p>在js中，我们可以构造一个装饰器函数，接收任何一个组件函数，返回一个增强功能的新组件，原组件其他功能不受影响，并且当该增强功能不再使用时，只需要在调用处去除包裹的装饰器函数即可，这样可插拔式的功能体验可使得代码变得简单而优雅。</p>
<h2 id="修饰函数的修饰器实现"><a href="#修饰函数的修饰器实现" class="headerlink" title="修饰函数的修饰器实现"></a>修饰函数的修饰器实现</h2><p>正是因为装饰器模式带来的种种好处，在es7标准中已经正式引入了装饰器特性，标志符为 <code>@</code>。我们可以设定如下情况：设计一个通用型的日志补丁，能够输出组件中某些方法的调用日志的功能，我们可以这样写：</p>
<blockquote>
<p>以下代码请务必在支持es7的环境下运行，如何使用请自行查阅babel相关文档</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  @decorateLog</span><br><span class="line">  addNum(num1, num2) &#123;</span><br><span class="line">    <span class="keyword">return</span> num1 + num2;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">decorateLog</span>(<span class="params">target, name, descriptor</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    value: <span class="function"><span class="keyword">function</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;name&#125;</span>.arguments：`</span>, args);</span><br><span class="line">      <span class="keyword">return</span> descriptor.value.apply(<span class="keyword">this</span>, args);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> comp = <span class="keyword">new</span> Component();</span><br><span class="line"><span class="keyword">const</span> res = comp.addNum(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`answer is:`</span>, res); <span class="comment">// addNum.arguments：[1, 2] answer is: 3</span></span><br></pre></td></tr></table></figure>
<p>不难看出，装饰器函数接收三个参数：被修饰对象，被修饰对象名，以及该对象属性描述符（参考<code>Object.defineProperty</code>中的<code>descriptor</code>属性），返回新的被修饰对象属性描述符。</p>
<h2 id="修饰类的修饰器实现"><a href="#修饰类的修饰器实现" class="headerlink" title="修饰类的修饰器实现"></a>修饰类的修饰器实现</h2><p>修饰器不仅能被用于修饰类属性，甚至能够直接修饰类本身，增强类功能。这个特性也十分实用。本质上，装饰器的行为就是一个高阶函数，其作用全等于以下用法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">decorator</span>(<span class="params">target</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Component</span> </span>&#123;&#125;</span><br><span class="line">Component = decorator(Component) || Component;</span><br></pre></td></tr></table></figure>
<p>之前在写redux相关的文章时也顺口提到过，connect这个高阶组件也能够用装饰器模式来实现，使得导出类变得更美观且易读。</p>
<p>这是不使用修饰器的connect组件写法，高阶函数显得冗长不易读，export导出物不够明显与直观。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Component</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> connect(mapStateToProps, mapDispatchToProps)(Component);</span><br></pre></td></tr></table></figure>
<p>使用装饰器后，写法变成了这样</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@connect(mapStateToProps, mapDispatchToProps)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Component</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>我们也参照上述写法，来实现自己的类修饰器。假设这样一种情况，我们需要对每一个类组件增添一个获取作者名的通用方法，那我们可以这样来做：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@decorateAuthor</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...其他属性</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">decorateAuthor</span>(<span class="params">target</span>) </span>&#123;</span><br><span class="line">  target.prototype.getAuthor = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'synccheng'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> comp = <span class="keyword">new</span> Component();</span><br><span class="line"><span class="built_in">console</span>.log(comp.getAuthor())</span><br></pre></td></tr></table></figure>
<p>需要注意的一点的是，在js中，装饰器只能用于类和类中的方法，不能用于函数。这是因为，修饰器函数是在编译时执行，而不是在运行时执行。因此，若之间在普通函数中使用会存在函数提升的问题，即先定义函数名称，并不赋值，在被修饰函数声明时只能取到undefined的修饰器值，导致调用结果与预期不符。</p>
<p>总而言之，在适当的时机使用修饰器模式能帮我们得到一份优雅、易读、可插拔式的代码体验，使用修饰器模式，不需要深入理解原有的代码逻辑就能直接开发新特性，在对老代码进行功能增强的时候，有着事半功倍的效果。</p>
]]></content>
      
        <categories>
            
            <category> 架构设计 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[设计模式的js实现(1)--单例模式]]></title>
      <url>/2019/09/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84js%E5%AE%9E%E7%8E%B0(1)--%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>在所有设计模式中，最基础同时也非常实用的一类就是单例模式了。单例模式，顾名思义，指的是在此种设计模式下，整个系统将只会构建一次实例，接下来每一次的新的生成都视为对第一次生成实例的引用。</p>
<p>其实，单例模式在我们的项目中运用的十分广泛，例如浏览器的全局变量window就是一个例子，所有声明的全局变量都要挂靠在window下，并且window变量只生成一次，全局都能够调用。再比如一些一些需要保持唯一性的组件，例如顶部提示框、对话框、抽屉组件等等，也都可以用单例模式来解决。</p>
<h2 id="基础实现"><a href="#基础实现" class="headerlink" title="基础实现"></a>基础实现</h2><p>接下来我们尝试着来实现一下单例模式的构造函数。假设我们现在想实现一个单例的顶部提示框组件，简单展示如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Notification</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(message = "") &#123;</span><br><span class="line">    <span class="keyword">this</span>.message = message;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  getMessage() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.message;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了实现所需的目标，我们需要为该类增添一个获取单例实例的函数getInstance。先定义一个标志位记录生成的实例，每次调用时检查，若未实例化则生成一个实例，否则返回之前生成实例的引用。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Notification.getInstance = <span class="function"><span class="keyword">function</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 若未生成过实例，则实例化该方法，并将实例引用赋值给一个属性，之后返回该属性</span></span><br><span class="line">  <span class="keyword">if</span> (!Notification.instance) &#123;</span><br><span class="line">    Notification.instance = <span class="keyword">new</span> Notification(...args);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> Notification.instance;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> a = Notification.getInstance();</span><br><span class="line"><span class="keyword">const</span> b = Notification.getInstance();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a === b); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>这样就实现了这个组件的单例化。</p>
<h2 id="能不能更通用"><a href="#能不能更通用" class="headerlink" title="能不能更通用"></a>能不能更通用</h2><p>上面这个例子能够实现所需要的目标，但是代码过于耦合，且不方便复用。我们可以考虑使用更通用的方法来实现这一目标。比如我们可以将单例逻辑抽离出来，在原组件外层包裹一个用于生成单例的函数，返回一个功能相同，但拥有单例功能的新组件。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Singleton = <span class="function"><span class="keyword">function</span>(<span class="params">Class</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> instance = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!instance) instance = <span class="keyword">new</span> Class(...args);</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> SingleNotification = <span class="keyword">new</span> Singleton(Notification);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> a = <span class="keyword">new</span> SingleNotification(<span class="string">"info"</span>);</span><br><span class="line"><span class="keyword">const</span> b = <span class="keyword">new</span> SingleNotification(<span class="string">"warning"</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(b.message); <span class="comment">// "info"</span></span><br><span class="line"></span><br><span class="line">b.message = <span class="string">"warning"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a.message); <span class="comment">// "warning"</span></span><br></pre></td></tr></table></figure>
<p>这样就实现了单例逻辑与实际功能组件的解耦。这里实际上用到了装饰器模式的一些思想，关于装饰器模式我们留到下一节说。</p>
]]></content>
      
        <categories>
            
            <category> 架构设计 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[利用 React 高阶组件实现一个面包屑导航]]></title>
      <url>/2018/11/12/%E5%88%A9%E7%94%A8%20React%20%E9%AB%98%E9%98%B6%E7%BB%84%E4%BB%B6%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E9%9D%A2%E5%8C%85%E5%B1%91%E5%AF%BC%E8%88%AA/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><hr>
<h2 id="1-什么是-React-高阶组件"><a href="#1-什么是-React-高阶组件" class="headerlink" title="1. 什么是 React 高阶组件"></a>1. 什么是 React 高阶组件</h2><p>React 高阶组件就是以高阶函数的方式包裹需要修饰的 React 组件，并返回处理完成后的 React 组件。React 高阶组件在 React 生态中使用的非常频繁，比如<code>react-router</code> 中的 <code>withRouter</code> 以及 <code>react-redux</code> 中 <code>connect</code> 等许多 API 都是以这样的方式来实现的。</p>
<h2 id="2-使用-React-高阶组件的好处"><a href="#2-使用-React-高阶组件的好处" class="headerlink" title="2. 使用 React 高阶组件的好处"></a>2. 使用 React 高阶组件的好处</h2><p>在工作中，我们经常会有很多功能相似，组件代码重复的页面需求，通常我们可以通过完全复制一遍代码的方式实现功能，但是这样页面的维护可维护性就会变得极差，需要对每一个页面里的相同组件去做更改。因此，我们可以将其中共同的部分，比如接受相同的查询操作结果、组件外同一的标签包裹等抽离出来，做一个单独的函数，并传入不同的业务组件作为子组件参数，而这个函数不会修改子组件，只是通过组合的方式将子组件包装在容器组件中，是一个无副作用的纯函数，从而我们能够在不改变这些组件逻辑的情况下将这部分代码解耦，提升代码可维护性。</p>
<h2 id="3-自己动手实现一个高阶组件"><a href="#3-自己动手实现一个高阶组件" class="headerlink" title="3. 自己动手实现一个高阶组件"></a>3. 自己动手实现一个高阶组件</h2><p>前端项目里，带链接指向的面包屑导航十分常用，但由于面包屑导航需要手动维护一个所有目录路径与目录名映射的数组，而这里所有的数据我们都能从 <code>react-router</code> 的路由表中取得，因此我们可以从这里入手，实现一个面包屑导航的高阶组件。</p>
<p>首先我们看看我们的路由表提供的数据以及目标面包屑组件所需要的数据：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里展示的是 react-router4 的route示例</span></span><br><span class="line"><span class="keyword">let</span> routes = [</span><br><span class="line">  &#123;</span><br><span class="line">    breadcrumb: <span class="string">'一级目录'</span>,</span><br><span class="line">    path: <span class="string">'/a'</span>,</span><br><span class="line">    component: <span class="built_in">require</span>(<span class="string">'../a/index.js'</span>).default,</span><br><span class="line">    items: [</span><br><span class="line">      &#123;</span><br><span class="line">        breadcrumb: <span class="string">'二级目录'</span>,</span><br><span class="line">        path: <span class="string">'/a/b'</span>,</span><br><span class="line">        component: <span class="built_in">require</span>(<span class="string">'../a/b/index.js'</span>).default,</span><br><span class="line">        items: [</span><br><span class="line">          &#123;</span><br><span class="line">            breadcrumb: <span class="string">'三级目录1'</span>,</span><br><span class="line">            path: <span class="string">'/a/b/c1'</span>,</span><br><span class="line">            component: <span class="built_in">require</span>(<span class="string">'../a/b/c1/index.js'</span>).default,</span><br><span class="line">            exact: <span class="literal">true</span>,</span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            breadcrumb: <span class="string">'三级目录2'</span>,</span><br><span class="line">            path: <span class="string">'/a/b/c2'</span>,</span><br><span class="line">            component: <span class="built_in">require</span>(<span class="string">'../a/b/c2/index.js'</span>).default,</span><br><span class="line">            exact: <span class="literal">true</span>,</span><br><span class="line">          &#125;,</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 理想中的面包屑组件</span></span><br><span class="line"><span class="comment">// 展示格式为 a / b / c1 并都附上链接</span></span><br><span class="line"><span class="keyword">const</span> BreadcrumbsComponent = <span class="function">(<span class="params">&#123; breadcrumbs &#125;</span>) =&gt;</span> (</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &#123;breadcrumbs.map(<span class="function">(<span class="params">breadcrumb, index</span>) =&gt;</span> (</span><br><span class="line">      &lt;span key=&#123;breadcrumb.props.path&#125;&gt;</span><br><span class="line">        &lt;link to=&#123;breadcrumb.props.path&#125;&gt;&#123;breadcrumb&#125;&lt;<span class="regexp">/link&gt;</span></span><br><span class="line"><span class="regexp">        &#123;index &lt; breadcrumbs.length - 1 &amp;&amp; &lt;i&gt; /</span> &lt;<span class="regexp">/i&gt;&#125;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>span&gt;</span><br><span class="line">    ))&#125;</span><br><span class="line">  &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">);</span></span><br></pre></td></tr></table></figure>
<p>这里我们可以看到，面包屑组件需要提供的数据一共有三种，一种是当前页面的路径，一种是面包屑所带的文字，一种是该面包屑的导航链接指向。</p>
<p>其中第一种我们可以通过 react-router 提供的 withRouter 高阶组件包裹，可使子组件获取到当前页面的 location 属性，从而获取页面路径。</p>
<p>后两种需要我们对 routes 进行操作，首先将 routes 提供的数据扁平化成面包屑导航需要的格式，我们可以使用一个函数来实现它。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 以递归的方式展平react router数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> flattenRoutes = <span class="function"><span class="params">arr</span> =&gt;</span></span><br><span class="line">  arr.reduce(<span class="function"><span class="keyword">function</span>(<span class="params">prev, item</span>) </span>&#123;</span><br><span class="line">    prev.push(item);</span><br><span class="line">    <span class="keyword">return</span> prev.concat(</span><br><span class="line">      <span class="built_in">Array</span>.isArray(item.items) ? flattenRoutes(item.items) : item</span><br><span class="line">    );</span><br><span class="line">  &#125;, []);</span><br></pre></td></tr></table></figure>
<p>之后将展平的目录路径映射与当前页面路径一同放入处理函数，生成面包屑导航结构。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> getBreadcrumbs = <span class="function">(<span class="params">&#123; flattenRoutes, location &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 初始化匹配数组match</span></span><br><span class="line">  <span class="keyword">let</span> matches = [];</span><br><span class="line"></span><br><span class="line">  location.pathname</span><br><span class="line">    <span class="comment">// 取得路径名，然后将路径分割成每一路由部分.</span></span><br><span class="line">    .split(<span class="string">'?'</span>)[<span class="number">0</span>]</span><br><span class="line">    .split(<span class="string">'/'</span>)</span><br><span class="line">    <span class="comment">// 对每一部分执行一次调用`getBreadcrumb()`的reduce.</span></span><br><span class="line">    .reduce(<span class="function">(<span class="params">prev, curSection</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 将最后一个路由部分与当前部分合并，比如当路径为 `/x/xx/xxx` 时，pathSection分别检查 `/x` `/x/xx` `/x/xx/xxx` 的匹配，并分别生成面包屑</span></span><br><span class="line">      <span class="keyword">const</span> pathSection = <span class="string">`<span class="subst">$&#123;prev&#125;</span>/<span class="subst">$&#123;curSection&#125;</span>`</span>;</span><br><span class="line">      <span class="keyword">const</span> breadcrumb = getBreadcrumb(&#123;</span><br><span class="line">        flattenRoutes,</span><br><span class="line">        curSection,</span><br><span class="line">        pathSection,</span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 将面包屑导入到matches数组中</span></span><br><span class="line">      matches.push(breadcrumb);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 传递给下一次reduce的路径部分</span></span><br><span class="line">      <span class="keyword">return</span> pathSection;</span><br><span class="line">    &#125;);</span><br><span class="line">  <span class="keyword">return</span> matches;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>然后对于每一个面包屑路径部分，生成目录名称并附上指向对应路由位置的链接属性。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> getBreadcrumb = <span class="function">(<span class="params">&#123; flattenRoutes, curSection, pathSection &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> matchRoute = flattenRoutes.find(<span class="function"><span class="params">ele</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; breadcrumb, path &#125; = ele;</span><br><span class="line">    <span class="keyword">if</span> (!breadcrumb || !path) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(</span><br><span class="line">        <span class="string">'Router中的每一个route必须包含 `path` 以及 `breadcrumb` 属性'</span></span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 查找是否有匹配</span></span><br><span class="line">    <span class="comment">// exact 为 react router4 的属性，用于精确匹配路由</span></span><br><span class="line">    <span class="keyword">return</span> matchPath(pathSection, &#123; path, <span class="attr">exact</span>: <span class="literal">true</span> &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回breadcrumb的值，没有就返回原匹配子路径名</span></span><br><span class="line">  <span class="keyword">if</span> (matchRoute) &#123;</span><br><span class="line">    <span class="keyword">return</span> render(&#123;</span><br><span class="line">      content: matchRoute.breadcrumb || curSection,</span><br><span class="line">      path: matchRoute.path,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 对于routes表中不存在的路径</span></span><br><span class="line">  <span class="comment">// 根目录默认名称为首页.</span></span><br><span class="line">  <span class="keyword">return</span> render(&#123;</span><br><span class="line">    content: pathSection === <span class="string">'/'</span> ? <span class="string">'首页'</span> : curSection,</span><br><span class="line">    path: pathSection,</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>之后由 render 函数生成最后的单个面包屑导航样式。单个面包屑组件需要为 render 函数提供该面包屑指向的路径 <code>path</code>, 以及该面包屑内容映射<code>content</code> 这两个 props。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> render = <span class="function">(<span class="params">&#123; content, path &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> componentProps = &#123; path &#125;;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> content === <span class="string">'function'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">content</span> &#123;<span class="attr">...componentProps</span>&#125; /&gt;</span>;</span></span><br><span class="line"><span class="xml">  &#125;</span></span><br><span class="line"><span class="xml">  return <span class="tag">&lt;<span class="name">span</span> &#123;<span class="attr">...componentProps</span>&#125;&gt;</span>&#123;content&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span>;</span></span><br><span class="line"><span class="xml">&#125;;</span></span><br></pre></td></tr></table></figure>
<p>有了这些功能函数，我们就能实现一个能为包裹组件传入当前所在路径以及路由属性的 React 高阶组件了。传入一个组件，返回一个新的相同的组件结构，这样便不会对组件外的任何功能与操作造成破坏。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> BreadcrumbsHoc = (</span><br><span class="line">  location = <span class="built_in">window</span>.location,</span><br><span class="line">  routes = []</span><br><span class="line">) =&gt; <span class="function"><span class="params">Component</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> BreadComponent = (</span><br><span class="line">    &lt;Component</span><br><span class="line">      breadcrumbs=&#123;getBreadcrumbs(&#123;</span><br><span class="line">        flattenRoutes: flattenRoutes(routes),</span><br><span class="line">        location,</span><br><span class="line">      &#125;)&#125;</span><br><span class="line">    /&gt;</span><br><span class="line">  );</span><br><span class="line">  <span class="keyword">return</span> BreadComponent;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> BreadcrumbsHoc;</span><br></pre></td></tr></table></figure>
<p>调用这个高阶组件的方法也非常简单，只需要传入当前所在路径以及整个 <code>react router</code> 生成的 <code>routes</code> 属性即可。<br>至于如何取得当前所在路径，我们可以利用 <code>react router</code> 提供的 <code>withRouter</code> 函数，如何使用请自行查阅相关文档。<br>值得一提的是，<code>withRouter</code> 本身就是一个高阶组件，能为包裹组件提供包括 <code>location</code> 属性在内的若干路由属性。所以这个 API 也能作为学习高阶组件一个很好的参考。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">withRouter(<span class="function">(<span class="params">&#123; location &#125;</span>) =&gt;</span></span><br><span class="line">  BreadcrumbsHoc(location, routes)(BreadcrumbsComponent)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<h2 id="4-Q-amp-A"><a href="#4-Q-amp-A" class="headerlink" title="4. Q&amp;A"></a>4. Q&amp;A</h2><ol>
<li>如果<code>react router</code> 生成的 <code>routes</code> 不是由自己手动维护的，甚至都没有存在本地，而是通过请求拉取到的，存储在 redux 里，通过 <code>react-redux</code> 提供的 <code>connect</code> 高阶函数包裹时，路由发生变化时并不会导致该面包屑组件更新。使用方法如下：</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mapStateToProps</span>(<span class="params">state</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    routes: state.routes,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">connect(mapStateToProps)(</span><br><span class="line">  withRouter(<span class="function">(<span class="params">&#123; location &#125;</span>) =&gt;</span></span><br><span class="line">    BreadcrumbsHoc(location, routes)(BreadcrumbsComponent)</span><br><span class="line">  )</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<hr>
<p>这其实是 <code>connect</code> 函数的一个<strong>bug</strong>。因为 react-redux 的 connect 高阶组件会为传入的参数组件实现 shouldComponentUpdate 这个钩子函数，导致<strong>只有 prop 发生变化时才触发更新相关的生命周期函数(含 render)</strong>，而很显然，我们的 location 对象并没有作为 prop 传入该参数组件。</p>
<p>官方推荐的做法是使用 <code>withRouter</code> 来包裹 <code>connect</code> 的 <code>return value</code>，即</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">withRouter(</span><br><span class="line">  connect(mapStateToProps)(<span class="function">(<span class="params">&#123; location, routes &#125;</span>) =&gt;</span></span><br><span class="line">    BreadcrumbsHoc(location, routes)(BreadcrumbsComponent)</span><br><span class="line">  )</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>其实我们从这里也可以看出，高阶组件同高阶函数一样，不会对组件的类型造成任何更改，因此高阶组件就如同链式调用一样，可以任意多层包裹来给组件传入不同的属性，在正常情况下也可以随意调换位置，在使用上非常的灵活。这种可插拔特性使得高阶组件非常受React生态的青睐，很多开源库里都能看到这种特性的影子，有空也可以都拿出来分析一下。</p>
]]></content>
      
        <categories>
            
            <category> JavaScript </category>
            
        </categories>
        
        
        <tags>
            
            <tag> React </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[CSS常用技巧笔记]]></title>
      <url>/2018/03/14/CSS%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A7%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><hr>
<p>CSS是每一个前端工程师都绕不过去的坎，熟练运用CSS后，实现同样一种效果我们可以有很多种写法，但由于兼容问题，通常简洁的写法并不能实现全平台统一效果，复杂的写法对性能又不太友好，导致我们在编写CSS过程中有很多需要注意的点，要踩很多的坑，因此用一个笔记来集中记录一下方法。</p>
<hr>
<p>(为方便表达代码，在此定义html结构为：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"parent"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"target"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>默认的css样式为：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#ccc</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">400px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.target</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#333</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">25%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>行内元素html结构改为：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"parent"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">label</span> <span class="attr">class</span>=<span class="string">"target"</span>&gt;</span>Duang<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>css样式改为：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.target</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#eee</span>;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">25px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>以下无特殊说明的话结构都使用这个)</p>
<h2 id="水平居中"><a href="#水平居中" class="headerlink" title="水平居中"></a>水平居中</h2><ol>
<li>行内元素</li>
</ol>
<p>只需要把行内元素包裹在一个属性display为block的父层元素中，并且把父层元素添加text-align:center 即可：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="http://ww1.sinaimg.cn/large/c527bb18gy1fpf1gom7jgj20d80bv3yd.jpg" alt></p>
<ol>
<li>块状元素</li>
</ol>
<p>对于块状元素来说，我们需要将它的左右外边距（即，margin-left，margin-right）设置为auto，即可实现块状元素的居中，如下：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.target</span> &#123;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span> auto;      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="http://ww1.sinaimg.cn/large/c527bb18gy1fpf0c51dkpj20cn0c3744.jpg" alt></p>
<h2 id="垂直居中"><a href="#垂直居中" class="headerlink" title="垂直居中"></a>垂直居中</h2><ol>
<li>行内元素单行居中</li>
</ol>
<p>对于单行行内元素来说，垂直居中就是设定父元素行高等于其块状元素高度。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">  <span class="attribute">line-height</span>: <span class="number">400px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.target</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: inline-block;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="http://ww1.sinaimg.cn/large/c527bb18gy1fpf1ei97zrj20dl0bpq2t.jpg" alt></p>
<ol>
<li>行内元素多行居中</li>
</ol>
<p>这个使用的手段是比较复杂的，我这里组合使用display:table-cell和vertical-align:middle属性来定义需要居中的元素的父容器元素，但是缺点有很多，比如这里因为格式变成了table类型，宽高必须设置成定值才行，希望有大佬提出更好的解决方法。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: table-cell;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">400px</span>;</span><br><span class="line">  <span class="attribute">vertical-align</span>:middle;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="http://ww1.sinaimg.cn/large/c527bb18gy1fpf1sw2qc6j20cv0btq32.jpg" alt></p>
<h2 id="水平垂直居中"><a href="#水平垂直居中" class="headerlink" title="水平垂直居中"></a>水平垂直居中</h2><p>这里的方法同样适用于仅水平或者仅垂直居中。取与之相关的居中代码即可。</p>
<ol>
<li>首先说说最通用且实用的首选方法。</li>
</ol>
<p>在不知道自己高度和父容器高度的情况下, 给父元素设置相对定位，子元素绝对定位，然后按照向右向下偏移的办法移到中心位置即可。</p>
<p>这里绝对定位的好处是无论父元素的实际高度以及子元素的个数，都能够完成覆盖型的居中显示。</p>
<p>代码示例如下：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.target</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">translate</span>(-50%, -50%);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>(注：其实这里可以不用知道父子元素高度，为了方便显示才使用)</p>
<p><img src="http://ww1.sinaimg.cn/large/c527bb18gy1fpeycpucu1j20g10c5dfp.jpg" alt></p>
<ol>
<li>如果已知父元素的高度，并且子元素有且只有一个的话，完全可以只对子元素使用相对定位完成同样的效果：</li>
</ol>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.target</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">translate</span>(-50%, -50%);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="http://ww1.sinaimg.cn/large/c527bb18gy1fpeycpucu1j20g10c5dfp.jpg" alt></p>
<ol>
<li>如果想实现多个子元素自适应的同时水平垂直居中，同时浏览器兼容性也支持的不错的话，推荐使用简单方便的flex布局。仅仅只设定父元素display属性为flex即可。</li>
</ol>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">align-items</span>: center;</span><br><span class="line">  <span class="attribute">justify-content</span>: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="http://ww1.sinaimg.cn/large/c527bb18gy1fpezr0dmvhj20ed0cbmx2.jpg" alt></p>
<ol>
<li>附加一个兼容性更好但是不太推荐的方法，就是由刚才多行行内元素垂直居中衍生出来的，再加一行行内水平居中的代码就能解决了。</li>
</ol>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: table-cell;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">400px</span>;</span><br><span class="line">  <span class="attribute">vertical-align</span>:middle;</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="http://ww1.sinaimg.cn/large/c527bb18gy1fpf20akarxj20cm0bywel.jpg" alt></p>
<p>不太推荐的原因同垂直居中时说的。<br>而且想实现这个效果还不如直接用一个块状元素包裹这些行内元素，然后再用块状元素的水平垂直居中即可，当然显示方式可能会有少许的不同，自己斟酌使用吧~</p>
<p>持续更新~</p>
]]></content>
      
        <categories>
            
            <category> CSS </category>
            
        </categories>
        
        
        <tags>
            
            <tag> css </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[git常用命令笔记]]></title>
      <url>/2018/01/03/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><hr>
<p>git是现如今最火的版本控制工具，尽管已经使用了github数年的时间了，但一直没有对git命令以及作用进行深入的分析和学习，对git的使用还仅停留在add、commit、push、clone上，这根本算不得掌握git。因此，这次一得出空来就开始从头恶补git知识了，分享出来与大家一同学习进步。</p>
<hr>
<h2 id="文件指针"><a href="#文件指针" class="headerlink" title="文件指针"></a>文件指针</h2><ol>
<li>git log可以查看历次提交信息，其中就有每一次提交的hash值，这对每一次提交都是唯一的文件指针。hash可以用短hash值表示，只需要在git log后加上–abbrev-commit 参数即可。</li>
<li>HEAD是一个特殊的文件指针，它指向当前工作区版本的位置。</li>
<li>^和~的意思都是指向该版本的父提交，如HEAD^与HEAD~其实是等价的，但是~2与^^等价，与^2不等价，^2指的是该版本的第二个父提交版本（因为在merge过后一个文件版本会有多个父版本）。</li>
</ol>
<h2 id="文件版本控制操作"><a href="#文件版本控制操作" class="headerlink" title="文件版本控制操作"></a>文件版本控制操作</h2><ol>
<li><p>git add <file>          // 将文件的修改从工作区添加至暂存区(staged)</file></p>
</li>
<li><p>git rm <file>            // 将删除文件这样一个修改操作提交到暂存区</file></p>
</li>
<li><p>git commit            // 将暂存区的所有修改提交入库</p>
<p>-m参数 填写提交内容的说明，–amend表示回退最近一次commit重新编写内容说明。</p>
<p>-a相当于自动做了一次<code>git add .</code>操作。</p>
</li>
</ol>
<ol>
<li><p>git checkout – <file></file></p>
<p>checkout命令有两种作用，后面加上 – （注意两边都有空格，是一个独立参数）后的意思是，将文件同步成版本库中最新的状态。相当于取消当前工作区的所有更改。但是这个操作不会影响暂存区(staged)中的内容。</p>
<p>这对本地已经删除但还没有git rm的文件同样适用，能够恢复本地工作区的文件。</p>
<p>但如果要修改的文件已经在暂存区的话，无论是git add还是git rm，就只能通过git reset恢复了，接下来介绍。</p>
<p>git checkout的另外一种意思在下面介绍。</p>
</li>
</ol>
<ol>
<li><p>git reset <hash></hash></p>
<p>这是个功能及其强大也及其复杂的命令。它表示在本地库回滚状态。</p>
<p>它主要有三种参数，分别代表三种不同效果的回滚。</p>
<p>–hard，是 git 中少有的几个会丢失信息的操作，它代表将该版本库中的内容强制覆盖本地文件，使得暂存区和工作区的状态强制与该版本同步。该操作不可逆，会使得你正在工作区和暂存区的文件修改完全丢失。不仅如此，被你回退之前的版本将会剔除出提交树中，不会显示在版本控制信息里，版本将无法回溯。因此慎用！非要使用的话最好先git stash缓存一下。</p>
<p>还有一种用法，如果我们希望彻底丢掉本地修改但是又希望保留当前branch所指向的版本的话，直接git reset –hard HEAD即可。</p>
<p>（当然，非要找回还是有办法的，使用git reflog查找那个版本的hash再git reset回来即可）</p>
<p>–soft，它使得文件的状态与HEAD指针都回退到指定版本的位置，并且同时，当前处于工作区和暂存区的文件都不会做任何更改。所有的在HEAD节点和你重置到的那个版本之间的所有变更集都放在暂存区中。</p>
<p>–mixed，为git reset的默认参数，混合了–hard与–soft的特点，它也将文件的状态与HEAD指针都回退到指定版本的位置，但只将暂存区与该版本强制同步，工作区的内容不会被更改。并且它也不会剔除</p>
<p>一张图能很好的说明上述操作的所有功能：</p>
</li>
</ol>
<ol>
<li><p>git merge <branch>        // 将该分支合并进当前分支</branch></p>
<p>这里的merge分<code>fast-forward</code>和<code>recursive</code>等模式，但git都能自动匹配最佳方案，就不提了。</p>
<p>要注意的是，合并过程中可能产生文件冲突。这时，当前分支会变为名叫<code>&lt;branch&gt;|MERGING</code>的临时分支，需要手动解决后，再次git add，git commit，才能产生新的合并提交。</p>
<p><img src="https://ws1.sinaimg.cn/large/c527bb18gy1fn3alf1wl1j20fb08t3yx.jpg" alt></p>
<p>​</p>
</li>
<li><p>git rebase <branch>        // 分支的衍合</branch></p>
<p>这个命令是在不希望产生合并的分支历史的特殊要求下使用的，功能方面大致类比git merge。因为不太常用，不做仔细介绍了。</p>
<p><img src="https://ws1.sinaimg.cn/large/c527bb18gy1fn3am5cjahj20i408u0t7.jpg" alt></p>
</li>
<li><p>git push <remote> <branch>        // 将本地某个分支的更新推送到远程</branch></remote></p>
<p>其中本地分支名可以与远程分支名不同步，将<branch>部分改写为<code>&lt;本地分支名&gt;:&lt;远程分支名&gt;</code>即可。</branch></p>
<p>这里还有一个特殊操作，如果不指定本地分支名，像是<code>:&lt;远程分支名&gt;</code>这样，表示删除该远程分支。</p>
<p>比较常用的参数如下：</p>
<p>-u，指定当前推送的主机为默认主机，这样后面就可以不加任何参数使用<code>git push</code>。不带任何参数的<code>git push</code>，默认只推送当前分支。</p>
<p>-d或–delete，删除该远程主机的该分支。如果当前分支与远程分支之间存在追踪关系，则本地分支和远程分支都可以省略。</p>
<p>-f或–force，当你需要提交一个有文件冲突的版本，需要本地强制覆盖远程时，使用这个参数，它将在远程主机产生一个”非直进式”的合并(non-fast-forward merge)。</p>
<p>–all，不管是否存在对应的远程分支，将本地的所有分支都推送到远程主机。</p>
<p>–tags，推送时将本地的tags标签也推送上去（默认不推送）。</p>
</li>
</ol>
<ol>
<li><p>git pull <remote> <branch>        // 取回远程主机某个分支的更新。</branch></remote></p>
<p>功能相当于同时执行了git fetch与git merge。参数大致与git push 相同，就不多做介绍了。</p>
</li>
<li><p>git pull <remote> <branch>        // 取回远程主机某个分支的更新。</branch></remote></p>
<p>功能相当于同时执行了git fetch与git merge。参数大致与git push 相同，就不多做介绍了。</p>
</li>
</ol>
<h2 id="状态信息查看操作"><a href="#状态信息查看操作" class="headerlink" title="状态信息查看操作"></a>状态信息查看操作</h2><ol>
<li><p>git remote        // 列出所有远程主机。</p>
<p><code>-v</code>选项，可以参看远程主机的网址。</p>
<p>git remote add &lt;主机名&gt;，添加远程主机。</p>
<p>git remote rm &lt;主机名&gt;，删除远程主机。</p>
<p>​</p>
</li>
<li><p>git branch        // 查看该版本的所有分支</p>
<p>默认只查看本地分支。<code>-r</code>选项，可以用来查看远程分支，<code>-a</code>选项查看所有分支。</p>
<p>git branch <branch></branch></p>
<p>表示新建分支。（若分支已存在，则报错。）</p>
<p>​</p>
</li>
<li><p>git checkout <branch></branch></p>
<p>又是这个命令，但是注意，这一次没有<code>--</code>命令，它表示将工作区跳转到该分支上。</p>
<p>若不存在该分支，可以使用<code>-b</code>参数新建该分支并跳转到该分支上。</p>
<p>​</p>
</li>
<li><p>git status        // 查看当前的工作区和暂存区文件修改</p>
</li>
<li><p>git reflog        // 查看该分支的历史提交记录</p>
<p>到目前我发现它最有用的地方就是记录了我<code>git reset --hard</code>之前的版本hash，可以让我恢复版本。</p>
</li>
<li><p>git log             // 查看该分支的提交记录</p>
<p>如果跟我一样不太喜欢用gitk这样的GUI的话，我提供几个常用参数作参考。参数对gitk也适用。</p>
<p>–oneline 给我的感觉相当于–pretty=oneline与–abbrev-commit的结合，只显示提交ID和提交信息的第一行。</p>
<p>–all 显示所有分支的信息。</p>
<p>–decorate标记让git log显示指向这个提交的所有引用（比如说分支、标签等）。</p>
<p>–graph选项绘制一个ASCII图像来展示提交历史的分支结构。</p>
<p>-[number]，表示只显示最后提交的若干列信息。</p>
<p>​</p>
</li>
<li><p>gitk                  // git log 的图形化界面版本</p>
</li>
</ol>
<p>不断更新~</p>
]]></content>
      
        <categories>
            
            <category> git </category>
            
        </categories>
        
        
        <tags>
            
            <tag> git </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[React原理深入(1)--virtual DOM]]></title>
      <url>/2017/12/17/React%E5%8E%9F%E7%90%86%E6%B7%B1%E5%85%A5(1)--virtual%20DOM/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>工欲善其事，必先利其器。想要用好react这个前端View层大杀器，深入理解其工作原理必不可少。理解一个框架是如何让某种操作得到优化的至关重要，知其然也要知其所以然，它有助于我们对这个框架的正确高效的使用，这是一个前端工程师成长的必经路程。</p>
]]></content>
      
        <categories>
            
            <category> JavaScript </category>
            
        </categories>
        
        
        <tags>
            
            <tag> React </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Redux深入理解(4)]]></title>
      <url>/2017/12/04/Redux%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3(4)/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>这一节主要来讲讲redux在react项目中的具体使用。</p>
<p>将学的新知识新组件集成进项目里是初学者最大的障碍，这也是我最初学习redux的时候很难有进展的原因。redux的源码体积很小，加起来连1k行都不到，利用的原理在之前已经说过，也很好理解，但由于redux只是flux对react的一种优化，但并不只是服务于react，如果你愿意，在vue中使用redux也是完全可行的，毕竟状态管理的思想还是不会变的嘛。</p>
<p>因此我们需要一个redux与react之间的连接件来方便我们的搭建，这就是<code>react-redux</code>。也是我们将redux合并进react最后也是最大的难点。</p>
<h2 id="react-redux的总体思想"><a href="#react-redux的总体思想" class="headerlink" title="react-redux的总体思想"></a><code>react-redux</code>的总体思想</h2><blockquote>
<p><code>react-redux</code> 将所有组件分成两大类：UI 组件和容器组件。</p>
</blockquote>
<p>UI组件和容器组件的定义很好理解。</p>
<p>UI组件不负责任何的交互逻辑，只负责展示，类比于纯函数，它是一个“纯组件”。不应该有自己定义的state，所有的状态和事件动作应全由上层的props获取。</p>
<p>容器组件则跟UI组件相反，可以有自己的状态，能处理业务交互逻辑。</p>
<blockquote>
<p><code>react-redux</code> 规定，所有的 UI 组件都由用户提供，容器组件则是由 <code>react-redux</code> 自动生成。也就是说，用户负责视觉层，状态管理则是全部交给它。</p>
</blockquote>
<p>这个思想完美的解决了逻辑数据处理与UI界面耦合的问题，让程序的思路更清晰，极大地提高开发与调试效率，这也是为什么越大型的项目越需要使用这样的状态管理组件的根本原因。</p>
<hr>
<p>之后我们来看看<code>react-redux</code>几个主要的功能方法：</p>
<h2 id="lt-Provider-store-store-gt-lt-app-gt-lt-app-gt-lt-Provider-gt"><a href="#lt-Provider-store-store-gt-lt-app-gt-lt-app-gt-lt-Provider-gt" class="headerlink" title="&lt;Provider store={store}&gt;&lt;app&gt;&lt;/app&gt;&lt;/Provider&gt;"></a><code>&lt;Provider store={store}&gt;&lt;app&gt;&lt;/app&gt;&lt;/Provider&gt;</code></h2><p>作为一个全局状态管理组件，我们首先应该想到的就是状态的传递。</p>
<p>最简单的想法是从应用的最外层传入当前的state状态，之后在接下来的每一层中层层props传递。但是这样做太麻烦了，而且很容易让传入状态难以维护，比如你要删去一个状态，就必须把这个组件下的所有子组件使用到这个状态的删除，不然就会报错。</p>
<p>我在<a href="http://kelekexiao.cn/2017/11/30/redux%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%EF%BC%88%E4%B8%80%EF%BC%89/">redux深入理解（一）</a>里面悄悄的提到了一个东西：context，也就是上下文，它可以实现祖先与后台之间的状态直接传值。这个特性被<code>react-redux</code>利用了，放入了Provider组件中。</p>
<p><provider>组件直接包裹在需要调用全局store的根组件的外层，然后传入属性store，即可在该根组件的任何后代组件中直接拿到state数据了。</provider></p>
<p>如果你的项目还需要用到react-router的话，Provider组件应包裹在router组件的外层。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;Provider store=&#123;store&#125;&gt;</span><br><span class="line">  &lt;Router&gt;</span><br><span class="line">    &lt;Route path=<span class="string">"/"</span> component=&#123;App&#125; /&gt;</span><br><span class="line">  &lt;<span class="regexp">/Router&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>Provider&gt;</span><br></pre></td></tr></table></figure>
<h2 id="connect-mapStateToProps-mapDispatchToProps-App"><a href="#connect-mapStateToProps-mapDispatchToProps-App" class="headerlink" title="connect(mapStateToProps, mapDispatchToProps)(App)"></a><code>connect(mapStateToProps, mapDispatchToProps)(App)</code></h2><p>之前说过，<code>react-redux</code>希望用户只编写UI组件而不用注意状态管理，容器组件则是由 <code>react-redux</code> 自动生成，那么生成的方法就是<code>connect()</code>方法，我们用它将外层的状态以props的方式传入进UI组件。</p>
<p><code>connect()</code>方法接受两个参数，<code>mapStateToProps</code>用于传递state，<code>mapDispatchToProps</code>用于传递UI组件需要调用的store.dispatch中的方法。</p>
<h2 id="mapStateToProps-state-ownProps"><a href="#mapStateToProps-state-ownProps" class="headerlink" title="mapStateToProps(state, ownProps)"></a><code>mapStateToProps(state, ownProps)</code></h2><p><code>mapStateToProps</code>是一个函数，它接受<code>state</code>作为参数，返回一个对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mapStateToProps = <span class="function">(<span class="params">state</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    name: state.name</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对象的键名代表 UI 组件的props中的同名参数，键值为你希望传入的处理过后的值。</p>
<p><code>mapStateToProps</code>会订阅 Store，每当<code>state</code>更新的时候，就会重新计算 UI 组件的参数，从而触发 UI 组件的重新渲染。</p>
<p>至于<code>mapStateToProps</code>的第二个参数<code>ownProps</code>是可选的，为该容器组件自身的props，传入后若容器组件自身的props被改变同样会触发UI组件的重新渲染。</p>
<h2 id="mapDispatchToProps"><a href="#mapDispatchToProps" class="headerlink" title="mapDispatchToProps()"></a><code>mapDispatchToProps()</code></h2><p><code>mapDispatchToProps</code>可以是一个函数，也可以是一个对象。它定义了UI组件中的一些操作能够发出action，被store响应。</p>
<p>当<code>mapDispatchToProps</code>作为对象时，结构与<code>mapStateToProps</code>类似。它的每个键名也是对应 UI 组件的同名参数，键值应该是一个函数，这个函数我们之前提到过，叫做<code>actionCreator</code> ，它返回的 action 会由 redux 自动发出。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mapDispatchToProps = &#123;</span><br><span class="line">  onClick: <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> action = &#123;</span><br><span class="line">      type: <span class="string">'SET_CURRENT_TARGET'</span>,</span><br><span class="line">      payload: &#123;</span><br><span class="line">         target: e.target       </span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> action</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当<code>mapDispatchToProps</code>是一个函数时，可以传入<code>dispatch</code>和<code>ownProps</code>（容器组件的<code>props</code>对象）两个参数。返回值仍然一个对象，该对象的每个键值对事实上都是一个映射，定义了 UI 组件的这个键名参数应该怎样dispatch，发出action。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mapDispatchToProps = <span class="function">(<span class="params">dispatch, ownProps</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    onClick: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      dispatch(&#123;</span><br><span class="line">        type: <span class="string">'SET_CURRENT_TARGET'</span>,</span><br><span class="line">        payload: &#123;</span><br><span class="line">           target: e.target       </span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> JavaScript </category>
            
        </categories>
        
        
        <tags>
            
            <tag> React </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Redux深入理解(3)]]></title>
      <url>/2017/12/03/Redux%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3(3)/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><hr>
<p>上一节说到，reducer是一个纯函数。那么纯函数具体的定义是什么呢？阮一峰老师是这样说的：</p>
<p>纯函数是函数式编程的概念，必须遵守以下一些约束。</p>
<blockquote>
<ul>
<li>不得改写参数</li>
</ul>
<ul>
<li>不能调用系统 I/O 的API</li>
</ul>
<ul>
<li>不能调用<code>Date.now()</code>或者<code>Math.random()</code>等不纯的方法，因为每次会得到不一样的结果</li>
</ul>
</blockquote>
<p>我们知道，处理业务逻辑的过程中不可避免的要用到异步操作，而reducer是一个纯函数，无法完成这项使命，那怎么办呢？</p>
<p>这又是一个非常复杂的故事了。</p>
<p>首先我想到的是，<code>action</code>不是由<code>actionCreator</code>函数生成的吗？我们可以在<code>actionCreator</code>函数里面进行异步操作，返回不同的<code>payload</code>，问题不就解决了吗？但是问题又来了，之前说过，reducer不能接收一个函数作为参数传入啊。</p>
<p>事实上，著名的中间件<code>redux-thunk</code>就是处理这样的问题的，使得<code>actionCreator</code>方法能接受一个返回action对象的函数作为返回值。</p>
<p>那么这里就引入了一个中间件的概念。中间件实际上就是用来修饰reducer操作，增强reducer函数功能的。</p>
<p>我们来看看redux中间件是怎么运作的：</p>
<blockquote>
<p>若reducer涉及到异步操作，则必须使用中间件。创建store时使用<code>applyMiddleware(middleware)(createStore)(reducer, initialState)</code>来创建store</p>
</blockquote>
<p>这看起来实在是太绕了……</p>
<p>实际上，我们可以将<code>applyMiddleware(middleware)</code>看成一个修饰器，用来修饰<code>createStore(reducer, initialState)</code>函数。是不是看明白了一点？</p>
<p>因此，这个函数我们也能写成这样：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> store = createStore(</span><br><span class="line">  reducer,</span><br><span class="line">  initial_state,</span><br><span class="line">  applyMiddleware(middleware)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>将<code>applyMiddleware(middleware)</code>作为<code>createStore</code>的最后一个参数传入，现在是不是好理解多了？</p>
<p>另外，中间件的传入是有顺序讲究的，涉及到执行顺序的问题，通过redux中<code>applyMiddleware</code>的源码中可以看出，<code>applyMiddleware(middleware1，middleware2，middleware3)</code>的实际执行顺序为<code>store.dispatch</code>=&gt;<code>middleware1</code>=&gt;<code>middleware2</code>=&gt;<code>middleware3</code>。这一点一定要非常小心，比如著名的redux-logger中间件是用来记录操作日志的，一定要放在最后一个参数中以便第一时间执行。</p>
<p>redux中间件的各种组件可谓是博大精深，有各种各样好用的中间件让人去探索学习，本文着重讲解redux本身的原理，对中间件插件就不多做介绍了。</p>
]]></content>
      
        <categories>
            
            <category> JavaScript </category>
            
        </categories>
        
        
        <tags>
            
            <tag> React </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Redux深入理解(2)]]></title>
      <url>/2017/12/01/Redux%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3(2)/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在理解了redux的作用原理后，我们来看看redux的基本概念。</p>
<h3 id="state"><a href="#state" class="headerlink" title="state"></a>state</h3><p><code>state</code>：state是状态管理的根本。在redux中，有唯一的状态树state，为整个应用共享。本质上是一个普通对象。处于程序逻辑中，无法直接调用。</p>
<h3 id="store"><a href="#store" class="headerlink" title="store"></a>store</h3><p><code>store</code>：store是state的管理者，一个应用同样只有唯一的store，管理着唯一的state。store包含下列四个函数：</p>
<blockquote>
<p><code>getState()</code> ：用于获取整个state</p>
<p><code>dispatch(action)</code> ：View触发action 改变 state 的<strong>唯一途径</strong>，请注意我用了<strong>唯一</strong>这个词</p>
<p><code>subscribe(listener)</code> ：可以理解成是 DOM 中的 addEventListener ，也就是我在上一篇里说过的发布订阅模式中的订阅方法，在redux的使用中，这个方法通常不需要手动使用，一般会放在setState方法中。</p>
<p><code>replaceReducer(nextReducer)</code> ：这个不太常用，一般在 Webpack Code-Splitting 按需加载的时候用获取state的方式：</p>
</blockquote>
<p>这几个方法中，<code>dispatch</code>函数略微难理解一点，单独提出来说说。</p>
<h3 id="dispatch"><a href="#dispatch" class="headerlink" title="dispatch"></a>dispatch</h3><p><code>dispatch(action)</code>用于View层想要更改 state 的操作，发布订阅模式中的发布操作。用于通知store做相应变更。</p>
<p>那么怎么让store知道变更哪一个属性呢？这里就要提到<code>action</code>了。<code>action</code>实际上是一个包含了<code>type</code>属性以及<code>payload</code>对象属性（这个叫载荷，不是必须的，但是在规范里推荐使用）的普通对象。其中<code>type</code>属性定义了应该进行的操作名。</p>
<p>我们从这里可以看出，由于载荷的存在，通常我们需要对<code>action</code>进行一些处理，因此，通常<code>action</code>对象由一个返回<code>action</code>对象的普通函数生成，一般我们称之为<code>actionCreator</code>函数。</p>
<p><code>actionCreator</code>函数不仅可以直接返回<code>action</code>对象，也可以返回一个闭包，闭包传入的参数可以为我们刚才介绍的store中的四个函数，最终结果必须返回一个<code>action</code>对象。</p>
<blockquote>
<p>注：<code>actionCreator</code>函数不能直接当做参数传入dispatch中，必须引入中间件<code>redux-thunk</code>。</p>
</blockquote>
<h3 id="createStore"><a href="#createStore" class="headerlink" title="createStore"></a>createStore</h3><p>于是问题来了，既然<code>state</code>是由<code>store</code>生成和管理的，那么这个<code>store</code>又是怎么来的呢？生成store的方式又需要用到一个新的函数：<code>createStore(reducer, intialState, applyMiddleware)</code>。（<code>initialState</code>参数可以设置初始state，非必须。<code>applyMiddleware(middlewares)</code>方法用于引入中间件，这里按住不表）这里又引出来一个新东西：reducer，这是干什么的呢？</p>
<h3 id="reducer"><a href="#reducer" class="headerlink" title="reducer"></a>reducer</h3><p>刚刚说到的 action ，我的简单的理解是：type的值就是函数名，payload的值就是函数的传入参数。那么这个特殊的“函数”在哪里执行呢？redux的思想是：当View层调用<code>dispatch</code>方法，发出相应的<code>action</code>给<code>store</code>，<code>store</code> 收到 <code>action</code> 以后，必须给出一个新的 <code>state</code>，这样 View 才会发生变化。这种 <code>state</code> 的计算过程就叫做 <code>reducer</code>。</p>
<p><code>reducer(oldState, action)</code>是一个纯函数（指任何时候输入同一个数据，返回的数据永远都相同，也就是说reducer函数中的处理不能带有任何异步操作），<code>reducer</code>负责对<code>state</code>操作，接收旧的state和action，根据<code>action.type</code>的类型以及<code>action.payload</code>中的数据，处理state并返回。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> reducer = <span class="function">(<span class="params">state, action</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'ADD'</span>:</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        ...state,</span><br><span class="line">        count: state.count + action.payload.num;</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'DELETE'</span>:</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        ...state,</span><br><span class="line">        count: state.count - action.payload.num;</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="keyword">default</span>: </span><br><span class="line">      <span class="keyword">return</span> state;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>一行代码简单来说就是<code>(oldState, action) =&gt; newState</code>。由于<code>reducer</code>是直接替换<code>state</code>，因此<code>reducer</code>必须有返回值。不然整个redux就会得不到<code>state</code>了。</p>
<p>话说一个计算变化重新生成state的方法为什么要叫reducer呢？我查了查资料，原来这个方法可以作为数组的<code>reduce</code>方法的参数。使用方法如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> actions = [</span><br><span class="line">  &#123; <span class="attr">type</span>: <span class="string">'ADD'</span>, <span class="attr">payload</span>: &#123;<span class="attr">num</span>: <span class="number">1</span>&#125; &#125;,</span><br><span class="line">  &#123; <span class="attr">type</span>: <span class="string">'ADD'</span>, <span class="attr">payload</span>: &#123;<span class="attr">num</span>: <span class="number">2</span>&#125; &#125;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> newState = actions.reduce(reducer, state); <span class="comment">// &#123;..., count: 3&#125;</span></span><br></pre></td></tr></table></figure>
<p>由于redux中，<code>reducer</code>和<code>state</code>一样，也是唯一的，因此如果我们需要根据不同的处理逻辑分割<code>reducer</code>的话，需要用<code>combineReducers({reducer})</code>将这些<code>reducer</code>合并成一个<code>rootReducer</code>。</p>
]]></content>
      
        <categories>
            
            <category> JavaScript </category>
            
        </categories>
        
        
        <tags>
            
            <tag> React </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Redux深入理解(1)]]></title>
      <url>/2017/11/30/Redux%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3(1)/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>学习react的过程中，redux的熟练掌握是一个绕不开并且很难绕过去的坎。接触react已经有一段时间了，甚至连一些小项目都用react做了不少了，但redux的使用上还是有诸多不理解不熟练的地方。正好有很长一段时间没有更过博客了，就从这里着手，增强一下自己的理解。</p>
<h2 id="先从解决全局事件的问题开始"><a href="#先从解决全局事件的问题开始" class="headerlink" title="先从解决全局事件的问题开始"></a>先从解决全局事件的问题开始</h2><p>我们都知道，react的数据流是单向的，这样做是为了保证数据同源。</p>
<p>一般来说，子组件可以直接从父组件提供的props中获取数据放入state或是渲染出来，但是子组件要影响父组件的state的话就比较困难了，一般来说需要从父组件写一个回调函数通过props传入子组件，子组件调用这个回调函数之后，值就能在父组件中获取了。</p>
<p>那么，如何与孙组件传值呢？依据单向数据流的思路，层层props传递，回调函数再层层传递回来，是不是在写法上就有点看不懂了？</p>
<p>那么，跟与这个组件几乎完全没关系的远房亲戚组件传值呢？数据状态管理上就非常混乱了。我们自然而然的会想到，是不是能设计出一种思路，解决多级无关层次属性传递的问题呢？</p>
<p>有计算机基础的同学应该会从设计模式中找到灵感。没错，发布-订阅模式啊，全局订阅一个事件，将监听函数的回调函数置入其中，之后让想要改变数据的操作dispatch一个action的话，会依次激活通知所有订阅了这个事件的组件，这样再也不用辛苦的一级一级传递数据了，岂不是美滋滋？</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> EventEmitter = &#123;</span><br><span class="line">  _events: &#123;&#125;,</span><br><span class="line">  dispatch: <span class="function"><span class="keyword">function</span> (<span class="params">event, data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>._events[event]) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>._events[event].length; i++)</span><br><span class="line">    	<span class="keyword">this</span>._events[event][i](data);</span><br><span class="line">  &#125;,</span><br><span class="line">  subscribe: <span class="function"><span class="keyword">function</span> (<span class="params">event, callback</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>._events[event]) </span><br><span class="line">      <span class="keyword">this</span>._events[event] = [];</span><br><span class="line">    <span class="keyword">this</span>._events[event].push(callback);</span><br><span class="line">  &#125;,</span><br><span class="line">  unSubscribe: <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>._events &amp;&amp; <span class="keyword">this</span>._events[event]) &#123;</span><br><span class="line">      <span class="keyword">delete</span> <span class="keyword">this</span>._events[event];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>是不是看起来很简单？事实上，redux本身的思路就是这么简单，甚至你可以直接拿这个自己写的“myRedux”中的发布订阅功能投入到react项目的使用中。举个例子：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> MyContainer = React.createClass(&#123;</span><br><span class="line">  render: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;CurItemPanel /&gt;</span><br><span class="line">        &lt;SelectionButtons/&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;);</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">var CurItemPanel = React.createClass(&#123;</span></span><br><span class="line"><span class="regexp">  getInitialState: function()&#123;</span></span><br><span class="line"><span class="regexp">    return &#123;</span></span><br><span class="line"><span class="regexp">      curItem: 'item1'</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">  &#125;,</span></span><br><span class="line"><span class="regexp">  componentDidMount: function()&#123;</span></span><br><span class="line"><span class="regexp">    var self = this;</span></span><br><span class="line"><span class="regexp">    EventEmitter.subscribe('changeItem', function(newItem)&#123;</span></span><br><span class="line"><span class="regexp">      self.setState(&#123;</span></span><br><span class="line"><span class="regexp">      	curItem: newItem</span></span><br><span class="line"><span class="regexp">      &#125;);</span></span><br><span class="line"><span class="regexp">    &#125;)</span></span><br><span class="line"><span class="regexp">  &#125;,</span></span><br><span class="line"><span class="regexp">  componentWillUnmount: function()&#123;</span></span><br><span class="line"><span class="regexp">    EventEmitter.unSubscribe('changeItem');</span></span><br><span class="line"><span class="regexp">  &#125;,</span></span><br><span class="line"><span class="regexp">  render: function()&#123;</span></span><br><span class="line"><span class="regexp">    return (</span></span><br><span class="line"><span class="regexp">      &lt;p&gt;The curItem is: &#123;this.state.curItem&#125;&lt;/</span>p&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> SelectionButtons = React.createClass(&#123;</span><br><span class="line">  onClickItem: <span class="function"><span class="keyword">function</span>(<span class="params">item</span>)</span>&#123;</span><br><span class="line">  EventEmitter.dispatch(<span class="string">'changeItem'</span>, item);</span><br><span class="line">  &#125;,</span><br><span class="line">  render: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;button onClick=&#123;<span class="keyword">this</span>.onClickItem.bind(<span class="keyword">this</span>, <span class="string">'item1'</span>)&#125;&gt;item1&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">        &lt;button onClick=&#123;this.onClickItem.bind(this, 'item2')&#125;&gt;item2&lt;/</span>button&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;);</span></span><br></pre></td></tr></table></figure>
<p>当点击按钮时，<code>SelectionButtons</code>的兄弟节点<code>CurItemPanel</code>可直接通过订阅的回调函数取得数据啦。</p>
<p>redux本身的思路就是这么简洁明了。</p>
<h2 id="有没有别的方法"><a href="#有没有别的方法" class="headerlink" title="有没有别的方法"></a>有没有别的方法</h2><p>如果你的工程的数据流动没有那么繁杂，不想加入redux库来强行增加代码复杂度，但又实在觉得单项数据流的祖先传值太不友好的话，react本身还提供了一个解决办法：Context（上下文）。它同样能解决层次传递的痛点，可以使子组件直接访问祖先组件数据，先写一个示例：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> CurItemWrapper = React.createClass(&#123;</span><br><span class="line">  render: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;CurItemPanel /&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;);</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">var CurItemPanel = React.createClass(&#123;</span></span><br><span class="line"><span class="regexp">  contextTypes: &#123;</span></span><br><span class="line"><span class="regexp">  	curItem: React.PropTypes.any</span></span><br><span class="line"><span class="regexp">  &#125;,</span></span><br><span class="line"><span class="regexp">  render: function()&#123;</span></span><br><span class="line"><span class="regexp">    return (</span></span><br><span class="line"><span class="regexp">      &lt;p&gt;The curItem is: &#123;this.context.curItem&#125;&lt;/</span>p&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> MyContainer = React.createClass(&#123;</span><br><span class="line">  getInitialState: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  	……</span><br><span class="line">  &#125;,</span><br><span class="line">  childContextTypes: &#123;</span><br><span class="line">    curItem: React.PropTypes.any,</span><br><span class="line">    changeItem: React.PropTypes.any</span><br><span class="line">  &#125;,</span><br><span class="line">  getChildContext: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      curItem: <span class="keyword">this</span>.state.curItem,</span><br><span class="line">      changeItem: <span class="keyword">this</span>.changeItem</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  changeItem: <span class="function"><span class="keyword">function</span>(<span class="params">item</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">    	curItem: item</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;,</span><br><span class="line">  render: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;CurItemWrapper /&gt;</span><br><span class="line">        &lt;ListWrapper changeItem=&#123;<span class="keyword">this</span>.changeItem&#125;/&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;);</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">var ListWrapper = React.createClass(&#123;</span></span><br><span class="line"><span class="regexp">  render: function()&#123;</span></span><br><span class="line"><span class="regexp">    return (</span></span><br><span class="line"><span class="regexp">      &lt;div&gt;</span></span><br><span class="line"><span class="regexp">      	&lt;List /</span>&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;);</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">var List = React.createClass(&#123;</span></span><br><span class="line"><span class="regexp">  contextTypes: &#123;</span></span><br><span class="line"><span class="regexp">  	changeItem: React.PropTypes.any</span></span><br><span class="line"><span class="regexp">  &#125;,</span></span><br><span class="line"><span class="regexp">  onClickItem: function(item)&#123;</span></span><br><span class="line"><span class="regexp">  	this.context.changeItem(item);</span></span><br><span class="line"><span class="regexp">  &#125;,</span></span><br><span class="line"><span class="regexp">  render: function()&#123;</span></span><br><span class="line"><span class="regexp">    return (</span></span><br><span class="line"><span class="regexp">      &lt;ul&gt;</span></span><br><span class="line"><span class="regexp">        &lt;li onClick=&#123;this.onClickItem.bind(this, 'item1')&#125;&gt; item1&lt;/</span>li&gt;</span><br><span class="line">        &lt;li onClick=&#123;<span class="keyword">this</span>.onClickItem.bind(<span class="keyword">this</span>, <span class="string">'item2'</span>)&#125;&gt;item2&lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/u</span>l&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> MyContainer = React.createClass(&#123;</span><br><span class="line">  getInitialState: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  	……</span><br><span class="line">  &#125;,</span><br><span class="line">  childContextTypes: &#123;</span><br><span class="line">    curItem: React.PropTypes.any,</span><br><span class="line">    changeItem: React.PropTypes.any</span><br><span class="line">  &#125;,</span><br><span class="line">  getChildContext: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      curItem: <span class="keyword">this</span>.state.curItem,</span><br><span class="line">      changeItem: <span class="keyword">this</span>.changeItem</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  changeItem: <span class="function"><span class="keyword">function</span>(<span class="params">item</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">    	curItem: item</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;,</span><br><span class="line">  render: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;CurItemWrapper /&gt;</span><br><span class="line">        &lt;ListWrapper changeItem=&#123;<span class="keyword">this</span>.changeItem&#125;/&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;);</span></span><br></pre></td></tr></table></figure>
<p>可以看出，通过指定<code>childContextTypes</code>后，父组件通过<code>getChildContext</code>方法可以直接获取到子孙组件中的context，而子孙组件通过调用context对象也能轻松获取来自祖先的回调函数，省去了中间商赚差价（误</p>
<p><code>getChildContext</code> 函数将会在每次state或者props改变时调用。为了更新context中的数据，使用 <code>this.setState</code>触发本地状态的更新。这将触发一个的context并且数据的改变可以被子元素收到。</p>
<p>但是！官方似乎并不希望context这个功能被广泛的使用，并声称在日后很可能下架这项功能。以下是原话：</p>
<blockquote>
<p>绝大多数的应用程序不需要使用上下文(context)。</p>
<p>如果你希望使用应用程序更加稳定，就不要使用上下文(context)。这只是一个实验性的 API ，并且可能在未来的 React 版本中移除。</p>
<p>如果你不熟悉 <a href="https://github.com/reactjs/redux" target="_blank" rel="noopener">Redux</a> 或者 <a href="https://github.com/mobxjs/mobx" target="_blank" rel="noopener">MobX</a> 这类 state 管理库，就不要使用 context 。在许多实际应用中，这些库以及和React 绑定是一个很好的管理 和许多组件相关的 state 。Redux 相比 context 是更好的解决方案。</p>
<p>如果你不是一个经验丰富的 React 开发者，就不要使用 context 。更好的方式是使用 props 和 state 。</p>
<p>如果你不顾这些警告仍然坚持使用 context ，尝试着将 context 的使用隔离在一个将小的范围内，并且在可能的情况下直接使用 context ，以便在API改变的时候进行升级。</p>
</blockquote>
<p>emmm，所以呀，我们还是尽情拥抱redux吧，作为一个状态管理flux的react优化版，还是很值得学习一番的。</p>
]]></content>
      
        <categories>
            
            <category> JavaScript </category>
            
        </categories>
        
        
        <tags>
            
            <tag> React </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[MongoDB极简实践入门]]></title>
      <url>/2017/09/17/MongoDB%E6%9E%81%E7%AE%80%E5%AE%9E%E8%B7%B5%E5%85%A5%E9%97%A8/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><hr>
<h2 id="为什么用MongoDB？"><a href="#为什么用MongoDB？" class="headerlink" title="为什么用MongoDB？"></a>为什么用MongoDB？</h2><p>传统的计算机应用大多使用关系型数据库来存储数据，比如大家可能熟悉的MySql, Sqlite等等，它的特点是数据以表格(table)的形式储存起来的。数据库由一张张排列整齐的表格构成，就好像一个Excel表单一样，每个表格会有若干列，比如一个学生信息表，可能包含学号、姓名、性别、入学年份、高考成绩、籍贯等等。而表格的每一排，则是一个个学生的具体信息。在企业级应用和前互联网时代，关系型数据库几乎是不二选择。关系型数据库的特点是有整齐划一的组织，很方便对数据进行描述、插入、搜索。</p>
<p>想象有一个传统的网上服装商店吧，它的主要的数据可能是储存在一张叫products的表单里，表单可能包含这些列：商品编号(ID)、名称(Name)、商家(brand)、主目录(cate)、子目录(sub-cat)、零售价(price)、是否促销(promotion)等等。如果有一个用户想要查找所有价格低于300元的正在促销的鞋子的编号和名称，则可以执行类似于以下的SQL语句：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT ID, name FROM products WHERE cate=&apos;shoes&apos; AND price&lt;300 and AND promotion=true;</span><br></pre></td></tr></table></figure></p>
<p>SQL具备了强大了的深度查询能力，能满足各式各样的查询要求。而如果要对数据进行添加和删除，成本也是非常低的。这些是SQL的优势之一， 但随着互联网的兴起以及数据形式的多样化，四平八稳的SQL表单在一些领域渐渐显现出它的劣势。让我们通过一个例子来说明。考虑一个博客后台系统，如果我们用关系型数据库为每篇博客(article)建一个表单的话，这个表单大概会包括以下这些列：</p>
<table>
<thead>
<tr>
<th>ID</th>
<th style="text-align:center">Title</th>
<th style="text-align:center">Description</th>
<th style="text-align:center">Author</th>
<th style="text-align:center">Content</th>
<th style="text-align:center">Likes</th>
</tr>
</thead>
<tbody>
<tr>
<td>A_1</td>
<td style="text-align:center">Title1</td>
<td style="text-align:center">Political Article</td>
<td style="text-align:center">Joe</td>
<td style="text-align:center">Content 1</td>
<td style="text-align:center">12</td>
</tr>
<tr>
<td>A_2</td>
<td style="text-align:center">Title2</td>
<td style="text-align:center">Humorous Story</td>
<td style="text-align:center">Sam</td>
<td style="text-align:center">Content 2</td>
<td style="text-align:center">50</td>
</tr>
</tbody>
</table>
<p>这时候用SQL数据库来存储是非常方便的，但假如我们要位每篇文章添加评论功能，会发现每篇文章可能要多篇评论，而且这个数目是动态变化的，而且每篇评论还包括好几项内容：评论的人、评论的时间、以及评论内容。这时候要将这些内容都塞进上述的那个表，就显得很困难。通常的做法是为评论(comment)单独建一个表：</p>
<table>
<thead>
<tr>
<th>ID</th>
<th style="text-align:center">Author</th>
<th style="text-align:center">Time</th>
<th style="text-align:center">Content</th>
<th style="text-align:center">Article</th>
</tr>
</thead>
<tbody>
<tr>
<td>C_1</td>
<td style="text-align:center">Anna</td>
<td style="text-align:center">2014-12-26 08:23</td>
<td style="text-align:center">Really good articles!</td>
<td style="text-align:center">A_1</td>
</tr>
<tr>
<td>C_2</td>
<td style="text-align:center">David</td>
<td style="text-align:center">2014-12-25 09:30</td>
<td style="text-align:center">I like it!</td>
<td style="text-align:center">A_1</td>
</tr>
</tbody>
</table>
<p>类似地，每篇文章可能会有若干标签(tags)。标签本身又是一个表单：</p>
<table>
<thead>
<tr>
<th>ID</th>
<th style="text-align:center">Category</th>
<th style="text-align:center">Tags</th>
<th style="text-align:center">Content</th>
<th style="text-align:center">Article</th>
</tr>
</thead>
<tbody>
<tr>
<td>T_1</td>
<td style="text-align:center">Anna</td>
<td style="text-align:center">2014-12-26 08:23</td>
<td style="text-align:center">Really good articles!</td>
<td style="text-align:center">A_1</td>
</tr>
<tr>
<td>T_2</td>
<td style="text-align:center">David</td>
<td style="text-align:center">2014-12-25 09:30</td>
<td style="text-align:center">I like it!</td>
<td style="text-align:center">A_2</td>
</tr>
</tbody>
</table>
<p>而博客的表格则要通过foreign key跟这些相关联的表格联系起来(可能还包括作者、出版社等其它表格)。这样一来，当我们做查询的时候，比如说，“找出评论数不少于3的标签为‘政治评论’的作者为Sam的文章”，就会涉及到复杂的跨表查询，需要大量使用<code>join</code>语句。这种跨表查询不仅降低了查询速度，而且这些语句写起来也不简单。</p>
<p>那么，如果用MongoDB数据库来实现，可以如何设计数据模型呢？很简单，像下面这样<a href="http://www.tutorialspoint.com/mongodb/mongodb_data_modeling.htm" target="_blank" rel="noopener">[1]</a>：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">_id: POST_ID</span><br><span class="line">title: TITLE_OF_POST, </span><br><span class="line">description: POST_DESCRIPTION,</span><br><span class="line">author: POST_BY,</span><br><span class="line">tags: [TAG1, TAG2, TAG3],</span><br><span class="line">likes: TOTAL_LIKES, </span><br><span class="line">comments: [	</span><br><span class="line">   &#123;</span><br><span class="line">      user:'COMMENT_BY',</span><br><span class="line">      message: TEXT,</span><br><span class="line">      dateCreated: DATE_TIME,</span><br><span class="line">   &#125;,</span><br><span class="line">   &#123;</span><br><span class="line">      user:'COMMENT_BY',</span><br><span class="line">      message: TEXT,</span><br><span class="line">      dateCreated: DATE_TIME,</span><br><span class="line">   &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>在MongoDB里，每篇博客文章以一个文档(document)的形式保存起来，而文档内部包含了很多项目，比如<code>title tags</code>等，每一个项目都是<code>key-value</code>的形式，即有一个项目的名字，比如<code>title</code>，以及它的值<code>TITLE_OF_POST</code>。而重要的是，一个<code>key</code>可以有多个<code>values</code>，他们用<code>[]</code>括起来。</p>
<p>这种“宽松”的数据存储形式非常灵活，MongoDB不限制每个<code>key</code>对应的<code>values</code>的数目。比如有的文章没有评论，则它的值就是一个空集，完全没有问题；有的文章评论很多，也可以无限制地插入。更灵活的是，MongoDB不要求同一个集合(collection，相当于SQL的table)里面的不同document有相同的key，比如除了上述这种文档组织，有的文档所代表的文章可能没有likes这个项目，再比如有的文章可能有更多的项目，比如可能还有dislikes等等。这些不同的文档都可以灵活地存储在同一个集合下，而且查询起来也异常简单，因为都在一个文档里，不用进行各种跨文档查询。而这种MongoDB式的存储也方便了数据的维护，对于一篇博客文章来说，所有的相关数据都在这个document里面，不用去考虑一个数据操作需要involve多少个表格。</p>
<p>当然，除了上述的优点，MongoDB还有不少别的优势，比如MongoDB的数据是用JSON(Javascript Object Notation)存储的(就是上面的这种key-value的形式)，而几乎所有的web应用都是基于Javascript的。因此，存储的数据和应用的数据的格式是高度一致的，不需经过转换。更多的优点可以查看：<a href="http://www.tutorialspoint.com/mongodb/mongodb_advantages.htm" target="_blank" rel="noopener">[2]</a>。</p>
<h2 id="关于这篇文章"><a href="#关于这篇文章" class="headerlink" title="关于这篇文章"></a>关于这篇文章</h2><p>这个极简教程，或者说笔记，并不是一个覆盖MongoDB方方面面的教程。所谓极简的意思，就是只选取那些最重要、最常用的内容进行基于实例的介绍，从而让读者能够在最短的时间内快速上手，并且能顺利地进行后续的纵深的学习。</p>
<p>具体地说，这个教程的特点是：</p>
<ul><br><li>不求全面，只求实用。只覆盖最核心的部分；</li><br><li>以大量例子为导向；</li><br><li>一边阅读一边动手操作的话，大约只需要2小时的时间；</li><br></ul>

<p>阅读这篇文章不需要有特别的基础，但最好知道数据库的基本概念，如果本身熟悉SQL那就更好啦。</p>
<h4>3. 安装与环境</h4>

<p>MongoDB可以在Windows、Linux、Mac OS X等主流平台运行，而且下载和安装非常简单，非常友好。这篇文档的例子采用MongoDB 2.6版本，均在OS X测试过，有充足的理由相信，在其它平台也能顺利运行。</p>
<p>Windows的安装和设置可以参考：<a href="http://www.w3cschool.cc/mongodb/mongodb-window-install.html；" target="_blank" rel="noopener">http://www.w3cschool.cc/mongodb/mongodb-window-install.html；</a></p>
<p>Linux的安装和设置可以参考：<a href="http://www.w3cschool.cc/mongodb/mongodb-linux-install.html；" target="_blank" rel="noopener">http://www.w3cschool.cc/mongodb/mongodb-linux-install.html；</a></p>
<p>Mac OS X下的安装和设置：</p>
<ul><br><li>1. 在<a href="https://www.mongodb.org/" target="_blank" rel="noopener">https://www.mongodb.org/</a> 下载适合你的Mac的MongoDb;</li><br><li>2. 下载得到的文件是一个zip文件，解压，然后放到你想到的文件夹，比如/Users/Steven/MongoDB;</li><br><li>3. 创建一个你喜欢的文件夹来存储你的数据，比如/User/Steven/myData;</li><br><li>4. 打开Terminal，cd到2里面那个文件夹/Users/Steven/MongoDB，再cd bin;</li><br><li>5. 输入./mongod –dbpath /User/Steven/myData,等到出现类似“waiting for connections on port 27017”，说明MongoDB服务器已架设好，而数据将储存在myData里面；</li><br><li>6. 新打开一个Terminal, cd /Users/Steven/MongoDB/bin,然后运行./mongo;顺利的话它将出现一个interactive shell让你进行各种操作，而你的数据将储存在myData里</li><br></ul>

<p>如果以上的各个步骤都运行顺利，就可以跳到下一节啦。</p>
<h4>4. 创建集合和删除集合</h4><br>在上一节执行完步骤6后，你会看到命令行里显示：<code>connecting to: test</code>，这里的<code>test</code>是默认的数据库。这里我们可以新建一个数据库。在命令行里打入：<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">use tutorial</span><br></pre></td></tr></table></figure><br><br>这样就新建了一个叫做<code>tutorial</code>的数据库。你可以执行<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show databases</span><br></pre></td></tr></table></figure><br><br>来显示当前的数据库。不过这时候由于我们的新数据库是空的，所以会显示类似这样的：<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">admin  (empty)</span><br><span class="line">local  0.078GB</span><br></pre></td></tr></table></figure><br><br>我们试着往我们的数据库里添加一个集合(collection)，MongoDB里的集合和SQL里面的表格是类似的：<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.createCollection(&apos;author&apos;)</span><br></pre></td></tr></table></figure><br><br>顺利的话会显示：<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; &quot;ok&quot; : 1 &#125;</span><br></pre></td></tr></table></figure><br><br>表示创建成功。<br><br>你可以再回头执行：<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show databases</span><br></pre></td></tr></table></figure><br><br>这时候我们的tutorial集合已经位列其中。你可以再执行<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show collections</span><br></pre></td></tr></table></figure><br><br>可以看到创建的集合author也在其中。<br><br>我们暂时不需要author这个集合，所以我们可以通过执行：<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.author.drop()</span><br></pre></td></tr></table></figure><br><br>来将其删除。这时候你再执行<code>show collections</code>，就再也看不到我们的author了。<br><br>这一节要记住的点主要只有一个：集合(collection)类似于SQL的表格(table)，类似于Excel的一个个表格。<br><br><h4>5. 插入</h4>

<p>想象一个精简版的“豆瓣电影”。我们需要创建一个数据库，来存储每部电影的信息，电影的信息包括：</p>
<ul><br><li>电影名字</li><br><li>导演</li><br><li>主演(可能多个)</li><br><li>类型标签(可能多个)</li><br><li>上映日期</li><br><li>喜欢人数</li><br><li>不喜欢人数</li><br><li>用户评论(可能多个)</li><br></ul>

<p>显然我们需要先创建一个叫电影的集合：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.createCollection(&apos;movie&apos;)</span><br></pre></td></tr></table></figure>
<p>然后，我们就可以插入数据了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">db.movie.insert(</span><br><span class="line"> &#123;</span><br><span class="line">   title: &apos;Forrest Gump&apos;, </span><br><span class="line">   directed_by: &apos;Robert Zemeckis&apos;,</span><br><span class="line">   stars: [&apos;Tom Hanks&apos;, &apos;Robin Wright&apos;, &apos;Gary Sinise&apos;],</span><br><span class="line">   tags: [&apos;drama&apos;, &apos;romance&apos;],</span><br><span class="line">   debut: new Date(1994,7,6,0,0),</span><br><span class="line">   likes: 864367,</span><br><span class="line">   dislikes: 30127,</span><br><span class="line">   comments: [	</span><br><span class="line">      &#123;</span><br><span class="line">         user:&apos;user1&apos;,</span><br><span class="line">         message: &apos;My first comment&apos;,</span><br><span class="line">         dateCreated: new Date(2013,11,10,2,35),</span><br><span class="line">         like: 0 </span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">         user:&apos;user2&apos;,</span><br><span class="line">         message: &apos;My first comment too!&apos;,</span><br><span class="line">         dateCreated: new Date(2013,11,11,6,20),</span><br><span class="line">         like: 0 </span><br><span class="line">      &#125;</span><br><span class="line">   ]</span><br><span class="line">&#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>请注意，这里插入数据之前，我们并不需要先声明movie这个集合里面有哪些项目。我们直接插入就可以了~这一点和SQL不一样，SQL必须先声明一个table里面有哪些列，而MongoDB不需要。</p>
<p>把上面的例子复制进命令行应该可以顺利运行，但我强烈建议你手动打一下，或者输入一部你自己喜欢的电影。<code>insert</code>操作有几点需要注意：</p>
<ul><br><li>1. 不同key-value需要用逗号隔开，而key:value中间是用冒号；</li><br><li>2. 如果一个key有多个value，value要用[]。哪怕当前只有一个value，也加上[]以备后续的添加；</li><br><li>3. 整个“数据块”要用{}括起来；</li><br></ul>

<p>如果你在<code>insert</code>之后看到<code>WriteResult({ &quot;nInserted&quot; : 1 })</code>，说明写入成功。</p>
<p>这个时候你可以用查询的方式来返回数据库中的数据：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.movie.find().pretty()</span><br></pre></td></tr></table></figure></p>
<p>这里<code>find()</code>里面是空的，说明我们不做限制和筛选，类似于SQL没有<code>WHERE</code>语句一样。而<code>pretty()</code>输出的是经格式美化后的数据，你可以自己试试没有<code>pretty()</code>会怎么样。</p>
<p>仔细观察<code>find()</code>的结果，你会发现多了一个叫<code>&#39;_id&#39;</code>的东西，这是数据库自动创建的一个ID号，在同一个数据库里，每个文档的ID号都是不同的。</p>
<p>我们也可以同时输入多个数据：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">db.movie.insert([</span><br><span class="line"> &#123;</span><br><span class="line">   title: &apos;Fight Club&apos;, </span><br><span class="line">   directed_by: &apos;David Fincher&apos;,</span><br><span class="line">   stars: [&apos;Brad Pitt&apos;, &apos;Edward Norton&apos;, &apos;Helena Bonham Carter&apos;],</span><br><span class="line">   tags: &apos;drama&apos;,</span><br><span class="line">   debut: new Date(1999,10,15,0,0),</span><br><span class="line">   likes: 224360,</span><br><span class="line">   dislikes: 40127,</span><br><span class="line">   comments: [	</span><br><span class="line">      &#123;</span><br><span class="line">         user:&apos;user3&apos;,</span><br><span class="line">         message: &apos;My first comment&apos;,</span><br><span class="line">         dateCreated: new Date(2008,09,13,2,35),</span><br><span class="line">         like: 0 </span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">         user:&apos;user2&apos;,</span><br><span class="line">         message: &apos;My first comment too!&apos;,</span><br><span class="line">         dateCreated: new Date(2003,10,11,6,20),</span><br><span class="line">         like: 14 </span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">         user:&apos;user7&apos;,</span><br><span class="line">         message: &apos;Good Movie!&apos;,</span><br><span class="line">         dateCreated: new Date(2009,10,11,6,20),</span><br><span class="line">         like: 2</span><br><span class="line">      &#125;</span><br><span class="line">   ]</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">   title: &apos;Seven&apos;, </span><br><span class="line">   directed_by: &apos;David Fincher&apos;,</span><br><span class="line">   stars: [&apos;Morgan Freeman&apos;, &apos;Brad Pitt&apos;,  &apos;Kevin Spacey&apos;],</span><br><span class="line">   tags: [&apos;drama&apos;,&apos;mystery&apos;,&apos;thiller&apos;],</span><br><span class="line">   debut: new Date(1995,9,22,0,0),</span><br><span class="line">   likes: 134370,</span><br><span class="line">   dislikes: 1037,</span><br><span class="line">   comments: [	</span><br><span class="line">      &#123;</span><br><span class="line">         user:&apos;user3&apos;,</span><br><span class="line">         message: &apos;Love Kevin Spacey&apos;,</span><br><span class="line">         dateCreated: new Date(2002,09,13,2,35),</span><br><span class="line">         like: 0 </span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">         user:&apos;user2&apos;,</span><br><span class="line">         message: &apos;Good works!&apos;,</span><br><span class="line">         dateCreated: new Date(2013,10,21,6,20),</span><br><span class="line">         like: 14 </span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">         user:&apos;user7&apos;,</span><br><span class="line">         message: &apos;Good Movie!&apos;,</span><br><span class="line">         dateCreated: new Date(2009,10,11,6,20),</span><br><span class="line">         like: 2</span><br><span class="line">      &#125;</span><br><span class="line">   ]</span><br><span class="line">&#125;</span><br><span class="line">])</span><br></pre></td></tr></table></figure></p>
<p>顺利的话会显示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">BulkWriteResult(&#123;</span><br><span class="line"> &quot;writeErrors&quot; : [ ],</span><br><span class="line"> &quot;writeConcernErrors&quot; : [ ],</span><br><span class="line"> &quot;nInserted&quot; : 2,</span><br><span class="line"> &quot;nUpserted&quot; : 0,</span><br><span class="line"> &quot;nMatched&quot; : 0,</span><br><span class="line"> &quot;nModified&quot; : 0,</span><br><span class="line"> &quot;nRemoved&quot; : 0,</span><br><span class="line"> &quot;upserted&quot; : [ ]</span><br></pre></td></tr></table></figure></p>
<p>表面我们成功地插入了两个数据。注意批量插入的格式是这样的：<code>db.movie.insert([{ITEM1},{ITEM2}])</code>。几部电影的外面需要用[]括起来。</p>
<p>请注意，虽然collection的插入不需要先声明，但表达相同意思的key，名字要一样，比如，如果我们在一个文档里用<code>directed_by</code>来表示导演，则在其它文档也要保持同样的名字(而不是<code>director</code>之类的)。不同的名字不是不可以，技术上完全可行，但会给查询和更新带来困难。</p>
<p>好了，到这里，我们就有了一个叫tutorial的数据库，里面有一个叫movie的集合，而movie里面有三个记录。接下来我们就可以对其进行查询了。</p>
<h4>6. 查询</h4>

<p>在上一节我们已经接触到最简单的查询<code>db.movie.find().pretty()</code>。MongoDB支持各种各样的深度查询功能。先来一个最简单的例子，找出大卫芬奇(David Fincher)导演的所有电影：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.movie.find(&#123;&apos;directed_by&apos;:&apos;David Fincher&apos;&#125;).pretty()</span><br></pre></td></tr></table></figure>
<p>将返回《搏击俱乐部》和《七宗罪》两部电影。这种搜索和SQL的<code>WHERE</code>语句是很相似的。</p>
<p>也可以设置多个条件。比如找出大卫芬奇导演的, 摩根弗里曼主演的电影：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.movie.find(&#123;&apos;directed_by&apos;:&apos;David Fincher&apos;, &apos;stars&apos;:&apos;Morgan Freeman&apos;&#125;).pretty()</span><br></pre></td></tr></table></figure>
<p>这里两个条件之间，是AND的关系，只有同时满足两个条件的电影才会被输出。同理，可以设置多个的条件，不赘述。</p>
<p>条件之间也可以是或的关系，比如找出罗宾怀特或摩根弗里曼主演的电影：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">db.movie.find(</span><br><span class="line">&#123;</span><br><span class="line">  $or: </span><br><span class="line">     [  &#123;&apos;stars&apos;:&apos;Robin Wright&apos;&#125;, </span><br><span class="line">        &#123;&apos;stars&apos;:&apos;Morgan Freeman&apos;&#125;</span><br><span class="line">     ]</span><br><span class="line">&#125;).pretty()</span><br></pre></td></tr></table></figure>
<p>注意这里面稍显复杂的各种括号。</p>
<p>还可以设置一个范围的搜索，比如找出50万人以上赞的电影：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.movie.find(&#123;&apos;likes&apos;:&#123;$gt:500000&#125;&#125;).pretty()</span><br></pre></td></tr></table></figure>
<p>同样要注意略复杂的括号。注意，在这些查询里，key的单引号都是可选的，也就是说，上述语句也可以写成：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.movie.find(&#123;likes:&#123;$gt:500000&#125;&#125;).pretty()</span><br></pre></td></tr></table></figure></p>
<p>类似地，少于二十万人赞的电影：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.movie.find(&#123;likes:&#123;$lt:200000&#125;&#125;).pretty()</span><br></pre></td></tr></table></figure>
<p>类似的运算符还有：<code>$let</code>:小于或等于；<code>$get</code>:大于或等于；<code>$ne</code>:不等于。</p>
<p>注意，对于包含多个值的key，同样可以用find来查询。比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.movie.find(&#123;&apos;tags&apos;:&apos;romance&apos;&#125;)</span><br></pre></td></tr></table></figure>
<p>将返回《阿甘正传》，虽然其标签既有romance，又有drama，但只要符合一个就可以了。</p>
<p>如果你确切地知道返回的结果只有一个，也可以用<code>findOne</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.movie.findOne(&#123;&apos;title&apos;:&apos;Forrest Gump&apos;&#125;)</span><br></pre></td></tr></table></figure>
<p>如果有多个结果，则会按磁盘存储顺序返回第一个。请注意，<code>findOne()</code>自带pretty模式，所以不能再加<code>pretty()</code>，将报错。</p>
<p>如果结果很多而你只想显示其中一部分，可以用<code>limit()</code>和<code>skip()</code>，前者指明输出的个数，后者指明从第二个结果开始数。比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.movie.find().limit(2).skip(1).pretty()</span><br></pre></td></tr></table></figure>
<p>则跳过第一部，从第二部开始选取两部电影。</p>
<h4>7. 局部查询</h4>

<p>第五节的时候我们讲了<code>find</code>的用法，但对于符合条件的条目，我们都是返回整个JSON文件的。这类似于SQL里面的<code>SELECT *</code>。有的时候，我们需要的，仅仅是部分数据，这个时候，<code>find</code>的局部查询的功能就派上用场了。先来看一个例子，返回tags为drama的电影的名字和首映日期。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.movie.find(&#123;&apos;tags&apos;:&apos;drama&apos;&#125;,&#123;&apos;debut&apos;:1,&apos;title&apos;:1&#125;).pretty()</span><br></pre></td></tr></table></figure>
<p>数据库将返回：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"> &quot;_id&quot; : ObjectId(&quot;549cfb42f685c085f1dd47d4&quot;),</span><br><span class="line"> &quot;title&quot; : &quot;Forrest Gump&quot;,</span><br><span class="line"> &quot;debut&quot; : ISODate(&quot;1994-08-05T16:00:00Z&quot;)</span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line"> &quot;_id&quot; : ObjectId(&quot;549cff96f685c085f1dd47d6&quot;),</span><br><span class="line"> &quot;title&quot; : &quot;Fight Club&quot;,</span><br><span class="line"> &quot;debut&quot; : ISODate(&quot;1999-11-14T16:00:00Z&quot;)</span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line"> &quot;_id&quot; : ObjectId(&quot;549cff96f685c085f1dd47d7&quot;),</span><br><span class="line"> &quot;title&quot; : &quot;Seven&quot;,</span><br><span class="line"> &quot;debut&quot; : ISODate(&quot;1995-10-21T16:00:00Z&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里find的第二个参数是用来控制输出的，1表示要返回，而0则表示不返回。默认值是0，但<code>_id</code>是例外，因此如果你不想输出<code>_id</code>，需要显式地声明：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.movie.find(&#123;&apos;tags&apos;:&apos;drama&apos;&#125;,&#123;&apos;debut&apos;:1,&apos;title&apos;:1,&apos;_id&apos;:0&#125;).pretty()</span><br></pre></td></tr></table></figure>
<h4>8. 更新</h4><br>很多情况下你需要更新你的数据库，比如有人对某部电影点了个赞，那么你需要更新相应的数据库。比如有人对《七宗罪》点了个赞，而它本来的赞的个数是134370，那么你需要更新到134371。可以这样操作：<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.movie.update(&#123;title:&apos;Seven&apos;&#125;, &#123;$set:&#123;likes:134371&#125;&#125;)</span><br></pre></td></tr></table></figure><br><br>第一个大括号里表明要选取的对象，第二个表明要改动的数据。请注意上述的操作相当不现实，因为你首先要知道之前的数字是多少，然后加一，但通常你不读取数据库的话，是不会知道这个数(134370)的。MongoDB提供了一种简便的方法，可以对现有条目进行增量操作。假设又有人对《七宗罪》点了两个赞，则可以：<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.movie.update(&#123;title:&apos;Seven&apos;&#125;, &#123;$inc:&#123;likes:2&#125;&#125;)</span><br></pre></td></tr></table></figure><br><br>如果你查询的话，会发现点赞数变为134373了，这里用的是<code>$inc</code>。除了增量更新，MongoDB还提供了很多灵活的更新选项，具体可以看：<a href="http://docs.mongodb.org/manual/reference/operator/update-field/" target="_blank" rel="noopener">http://docs.mongodb.org/manual/reference/operator/update-field/</a> 。<br><br>注意如果有多部符合要求的电影。则默认只会更新第一个。如果要多个同时更新，要设置<code>{multi:true}</code>，像下面这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.movie.update(&#123;&#125;, &#123;$inc:&#123;likes:10&#125;&#125;,&#123;multi:true&#125;)</span><br></pre></td></tr></table></figure><br><br>所有电影的赞数都多了10.<br><br>注意，以上的更新操作会替换掉原来的值，所以如果你是想在原有的值得基础上增加一个值的话，则应该用<code>$push</code>，比如，为《七宗罪》添加一个popular的tags。<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.movie.update(&#123;&apos;title&apos;:&apos;Seven&apos;&#125;, &#123;$push:&#123;&apos;tags&apos;:&apos;popular&apos;&#125;&#125;)</span><br></pre></td></tr></table></figure><br><br>你会发现《七宗罪》现在有四个标签：<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&quot;tags&quot; : [</span><br><span class="line"> &quot;drama&quot;,</span><br><span class="line"> &quot;mystery&quot;,</span><br><span class="line"> &quot;thiller&quot;,</span><br><span class="line"> &quot;popular&quot;</span><br><span class="line">],</span><br></pre></td></tr></table></figure><br><br><h4>9. 删除</h4>

<p>删除的句法和find很相似，比如，要删除标签为romance的电影，则：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.movie.remove(&#123;&apos;tags&apos;:&apos;romance&apos;&#125;)</span><br></pre></td></tr></table></figure></p>
<p>考虑到我们数据库条目异常稀少，就不建议你执行这条命令了~</p>
<p>注意，上面的例子会删除所有标签包含romance的电影。如果你只想删除第一个，则<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.movie.remove(&#123;&apos;tags&apos;:&apos;romance&apos;&#125;,1)</span><br></pre></td></tr></table></figure></p>
<p>如果不加任何限制：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.movie.remove()</span><br></pre></td></tr></table></figure>
<p>会删除movie这个集合下的所有文档。</p>
<h4>10. 索引和排序</h4>

<p>为文档中的一些key加上索引(index)可以加快搜索速度。这一点不难理解，假如没有没有索引，我们要查找名字为Seven的电影，就必须在所有文档里逐个搜索。而如果对名字这个key加上索引值，则电影名这个字符串和数字建立了映射，这样在搜索的时候就会快很多。排序的时候也是如此，不赘述。MongoDB里面为某个key加上索引的方式很简单，比如我们要对导演这个key加索引，则可以：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.movie.ensureIndex(&#123;directed_by:1&#125;)</span><br></pre></td></tr></table></figure></p>
<p>这里的1是升序索引，如果要降序索引，用-1。</p>
<p>MongoDB支持对输出进行排序，比如按名字排序：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.movie.find().sort(&#123;&apos;title&apos;:1&#125;).pretty()</span><br></pre></td></tr></table></figure></p>
<p>同样地，1是升序，-1是降序。默认是1。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.movie.getIndexes()</span><br></pre></td></tr></table></figure>
<p>将返回所有索引，包括其名字。</p>
<p>而</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.movie.dropIndex(&apos;index_name&apos;)</span><br></pre></td></tr></table></figure>
<p>将删除对应的索引。</p>
<h4>11. 聚合</h4>

<p>MongoDB支持类似于SQL里面的<code>GROUP BY</code>操作。比如当有一张学生成绩的明细表时，我们可以找出每个分数段的学生各有多少。为了实现这个操作，我们需要稍加改动我们的数据库。执行以下三条命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">db.movie.update(&#123;title:&apos;Seven&apos;&#125;,&#123;$set:&#123;grade:1&#125;&#125;)</span><br><span class="line">db.movie.update(&#123;title:&apos;Forrest Gump&apos;&#125;,&#123;$set:&#123;grade:1&#125;&#125;)</span><br><span class="line">db.movie.update(&#123;title:&apos;Fight Club&apos;&#125;,&#123;$set:&#123;grade:2&#125;&#125;)</span><br></pre></td></tr></table></figure>
<p>这几条是给每部电影加一个虚拟的分级，前两部是归类是一级，后一部是二级。</p>
<p>这里你也可以看到MongoDB的强大之处：可以动态地后续添加各种新项目。</p>
<p>我们先通过聚合来找出总共有几种级别。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.movie.aggregate([&#123;$group:&#123;_id:&apos;$grade&apos;&#125;&#125;])</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123; &quot;_id&quot; : 2 &#125;</span><br><span class="line">&#123; &quot;_id&quot; : 1 &#125;</span><br></pre></td></tr></table></figure>
<p>注意这里的2和1是指级别，而不是每个级别的电影数。这个例子看得清楚些：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.movie.aggregate([&#123;$group:&#123;_id:&apos;$directed_by&apos;&#125;&#125;])</span><br></pre></td></tr></table></figure>
<p>这里按照导演名字进行聚合。输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123; &quot;_id&quot; : &quot;David Fincher&quot; &#125;</span><br><span class="line">&#123; &quot;_id&quot; : &quot;Robert Zemeckis&quot; &#125;</span><br></pre></td></tr></table></figure>
<p>接着我们要找出，每个导演的电影数分别有多少：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.movie.aggregate([&#123;$group:&#123;_id:&apos;$directed_by&apos;,num_movie:&#123;$sum:1&#125;&#125;&#125;])</span><br></pre></td></tr></table></figure>
<p>将会输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123; &quot;_id&quot; : &quot;David Fincher&quot;, &quot;num_movie&quot; : 2 &#125;</span><br><span class="line">&#123; &quot;_id&quot; : &quot;Robert Zemeckis&quot;, &quot;num_movie&quot; : 1 &#125;</span><br></pre></td></tr></table></figure>
<p>注意$sum后面的1表示只是把电影数加起来，但我们也可以统计别的数据，比如两位导演谁的赞比较多：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.movie.aggregate([&#123;$group:&#123;_id:&apos;$directed_by&apos;,num_likes:&#123;$sum:&apos;$likes&apos;&#125;&#125;&#125;])</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123; &quot;_id&quot; : &quot;David Fincher&quot;, &quot;num_likes&quot; : 358753 &#125;</span><br><span class="line">&#123; &quot;_id&quot; : &quot;Robert Zemeckis&quot;, &quot;num_likes&quot; : 864377 &#125;</span><br></pre></td></tr></table></figure>
<p>注意这些数据都纯属虚构啊！</p>
<p>除了<code>$sum</code>，还有其它一些操作。比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.movie.aggregate([&#123;$group:&#123;_id:&apos;$directed_by&apos;,num_movie:&#123;$avg:&apos;$likes&apos;&#125;&#125;&#125;])</span><br></pre></td></tr></table></figure></p>
<p>统计平均的赞。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.movie.aggregate([&#123;$group:&#123;_id:&apos;$directed_by&apos;,num_movie:&#123;$first:&apos;$likes&apos;&#125;&#125;&#125;]</span><br></pre></td></tr></table></figure>
<p>返回每个导演的电影中的第一部的赞数。</p>
<p>其它各种操作可以参考：<a href="http://docs.mongodb.org/manual/reference/operator/aggregation/group/" target="_blank" rel="noopener">http://docs.mongodb.org/manual/reference/operator/aggregation/group/</a> 。</p>
<h4>12. All or Nothing?</h4>

<p>MongoDB支持单个文档内的原子化操作(atomic operation)，这是说，可以将多条关于同一个文档的指令放到一起，他们要么一起执行，要么都不执行。而不会执行到一半。有些场合需要确保多条执行一起顺次执行。比如一个场景：一个电商网站，用户查询某种商品的剩余数量，以及用户购买该种商品，这两个操作，必须放在一起执行。不然的话，假定我们先执行剩余数量的查询，这是假定为1，用户接着购买，但假如这两个操作之间还加入了其它操作，比如另一个用户抢先购买了，那么原先购买用户的购买的行为就会造成数据库的错误，因为实际上这种商品以及没有存货了。但因为查询剩余数量和购买不是在一个“原子化操作”之内，因此会发生这样的错误<a href="http://www.tutorialspoint.com/mongodb/mongodb_atomic_operations.htm" target="_blank" rel="noopener">[2]</a>。</p>
<p>MongoDB提供了<code>findAndModify</code>的方法来确保atomic operation。比如这样的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">db.movie.findAndModify(</span><br><span class="line">   &#123;</span><br><span class="line">   query:&#123;&apos;title&apos;:&apos;Forrest Gump&apos;&#125;,</span><br><span class="line">   update:&#123;$inc:&#123;likes:10&#125;&#125;</span><br><span class="line">   &#125;</span><br><span class="line">        )</span><br></pre></td></tr></table></figure></p>
<p>query是查找出匹配的文档，和find是一样的，而update则是更新likes这个项目。注意由于MongoDB只支持单个文档的atomic operation，因此如果query出多于一个文档，则只会对第一个文档进行操作。</p>
<p><code>findAndModify</code>还支持更多的操作，具体见：<a href="http://docs.mongodb.org/manual/reference/command/findAndModify/。" target="_blank" rel="noopener">http://docs.mongodb.org/manual/reference/command/findAndModify/。</a></p>
<h4>13. 文本搜索</h4>

<p>除了前面介绍的各种深度查询功能，MongoDB还支持文本搜索。对文本搜索之前，我们需要先对要搜索的key建立一个text索引。假定我们要对标题进行文本搜索，我们可以先这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.movie.ensureIndex(&#123;title:&apos;text&apos;&#125;)</span><br></pre></td></tr></table></figure>
<p>接着我们就可以对标题进行文本搜索了，比如，查找带有”Gump”的标题：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.movie.find(&#123;$text:&#123;$search:&quot;Gump&quot;&#125;&#125;).pretty()</span><br></pre></td></tr></table></figure>
<p>注意text和search前面的$符号。</p>
<p>这个例子里，文本搜索作用不是非常明显。但假设我们要搜索的key是一个长长的文档，这种text search的方便性就显现出来了。MongoDB目前支持15种语言的文本搜索。</p>
<h4>14. 正则表达式</h4>

<p>MongoDB还支持基于正则表达式的查询。如果不知道正则表达式是什么，可以参考<a href="http://en.wikipedia.org/wiki/Regular_expression" target="_blank" rel="noopener">Wikipedia</a>。这里简单举几个例子。比如，查找标题以<code>b</code>结尾的电影信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.movie.find(&#123;title:&#123;$regex:&apos;.*b$&apos;&#125;&#125;).pretty()</span><br></pre></td></tr></table></figure>
<p>也可以写成：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.movie.find(&#123;title:/.*b$/&#125;).pretty()</span><br></pre></td></tr></table></figure>
<p>查找含有’Fight’标题的电影：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.movie.find(&#123;title:/Fight/&#125;).pretty()</span><br></pre></td></tr></table></figure>
<p>注意以上匹配都是区分大小写的，如果你要让其不区分大小写，则可以：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.movie.find(&#123;title:&#123;$regex:&apos;fight.*b&apos;,$options:&apos;$i&apos;&#125;&#125;).pretty()</span><br></pre></td></tr></table></figure>
<p><code>$i</code>是insensitive的意思。这样的话，即使是小写的fight，也能搜到了。</p>
<h4>15. 后记</h4>

<p>至此，MongoDB的最基本的内容就介绍得差不多了。如果有什么遗漏的以后我会补上來。如果你一路看到底完全了这个入门教程，恭喜你，你一定是一个有毅力的人。</p>
<p>把这个文档过一遍，不会让你变成一个MongoDB的专家(如果会那就太奇怪了)。但如果它能或多或少减少你上手的时间，或者让你意识到“咦，MongoDB其实没那么复杂”，那么这个教程的目的也就达到啦。</p>
<p>这个文档是匆忙写就的，出错简直是一定的。如果您发现了任何错误或者有关于本文的任何建议，麻烦发邮件给我（stevenslxie at gmail.com）或者在GitHub上直接交流，不胜感激。</p>
<p></p><h4>转载声明</h4><br>如果你喜欢这篇文章，可以随意转载。但请<p></p>
<ul><br><li>标明原作者StevenSLXie;</li><br><li>标明原链接(<a href="https://github.com/StevenSLXie/Tutorials-for-Web-Developers/blob/master/MongoDB%20%E6%9E%81%E7%AE%80%E5%AE%9E%E8%B7%B5%E5%85%A5%E9%97%A8.md" target="_blank" rel="noopener">https://github.com/StevenSLXie/Tutorials-for-Web-Developers/blob/master/MongoDB%20%E6%9E%81%E7%AE%80%E5%AE%9E%E8%B7%B5%E5%85%A5%E9%97%A8.md</a>);</li><br><li>在可能的情况下请保持文本显示的美观。比如，请不要直接一键复制到博客之类，因为代码的显示效果可能非常糟糕;</li><br><li>请将这个转载声明包含进来；</li><br></ul>
]]></content>
      
        <categories>
            
            <category> NodeJS </category>
            
        </categories>
        
        
        <tags>
            
            <tag> MongoDB </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[github建立repository并上传工程的方法]]></title>
      <url>/2017/07/02/github%E5%BB%BA%E7%AB%8Brepository%E5%B9%B6%E4%B8%8A%E4%BC%A0%E5%B7%A5%E7%A8%8B%E7%9A%84%E6%96%B9%E6%B3%95/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><hr>
<p>这不是什么新知识了，自从我用github以来一直就是这么用着的，但是最近有一段时间没上传过自己的project了，竟然手生了忘了怎么做了。想了想还是记录下来比较好，也给大家分享分享。</p>
<p>由于是给自己做的备忘，怎么注册github之类的新手问题我就不说了，不懂的朋友可以自行去百度相关问题，很多的。</p>
<hr>
<ol>
<li>先clone再写入的方法（适用于还未开发项目时）</li>
</ol>
<p>通常最简单最无脑的办法就是现在github网站上创建一个repository，可以自己任意设定名字和readme.md。之后通过：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> git@github.com:username/respositoryname.git</span><br></pre></td></tr></table></figure>
<p>克隆到本地，之后往里面写入文件文件夹就行了。</p>
<p>写完想要提交到github的话,就输入如下命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git pull</span><br><span class="line">git add .</span><br><span class="line">git commit -m <span class="string">"first commit"</span></span><br><span class="line">git push origin master</span><br></pre></td></tr></table></figure>
<p>这里最好先git pull 一下，以免有冲突导致提交不成功。</p>
<ol>
<li>对本地项目git init再提交（适用于项目已经成型，想要在此时进行版本控制）</li>
</ol>
<p>如果你已经写好了工程但还没有进行过git版本控制，或者直接是从别的地方下载好的github上的工程还没有进入你自己的代码库的话，可以使用这种方法：</p>
<p>首先，如果你的工程完全没有经过git版本控制，那么在你的工程目录中输入命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br><span class="line">touch .gitignore</span><br></pre></td></tr></table></figure>
<p>之后你的工程里会多出一个.git的文件夹，之后你需要建立一个.gitignore文件，来建立规则忽略你不想传上github进行版本控制的文件或文件夹（一般为依赖库、数据库或者一些隐私文件），配置规则请百度。</p>
<p>之后的操作跟方法一大体相同，指定要提交到的远程repository，并注意同步冲突问题，之后提交即可。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit -m <span class="string">"first commit"</span></span><br><span class="line">git remote add origin git@github.com:username/respositoryname.git</span><br><span class="line">git pull origin master</span><br><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure>
<p>其实github还提供了一个方法：import code from another repository，从别的版本库中导入工程，这个就不细说了，因为git是公认的目前最好的版本控制库，根本不需要再放在别的地方了。有历史原因的工程想导入的话完全可以先下载下来，再参照方法一二进行。</p>
]]></content>
      
        <categories>
            
            <category> git </category>
            
        </categories>
        
        
        <tags>
            
            <tag> git </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[在linux下nodejs的安装方法大全]]></title>
      <url>/2017/06/11/%E5%9C%A8linux%E4%B8%8Bnodejs%E7%9A%84%E5%AE%89%E8%A3%85%E6%96%B9%E6%B3%95/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><hr>
<p>这段时间为了上线测试很多nodejs代码的部署，开始鼓捣云服务器。由于不是很懂运维知识，首先在安装上就踩了很多大坑，于是决定记录下来做个备忘。</p>
<hr>
<p>首先，我们可以去<a href="https://nodejs.org/en/download/current/" target="_blank" rel="noopener">nodejs官网</a>下载代码。</p>
<p>页面大概长成这样，上面有不同系统的不同位版本的下载，也可以点击上面的连接直接下载源码。</p>
<p><img src="https://raw.githubusercontent.com/kelekexiao123/markdown-image/master/node-install-linux-01.jpg" alt="01.jpg"></p>
<hr>
<h2 id="第一种方法，直接使用编译好的版本。"><a href="#第一种方法，直接使用编译好的版本。" class="headerlink" title="第一种方法，直接使用编译好的版本。"></a>第一种方法，直接使用编译好的版本。</h2><p>这是我认为最简单最好用的方法，直接下载官网的可编译版本的压缩包，然后用ftp导入到服务器中。当然你也可以直接在服务器中输入下载链接下载下来。</p>
<p>之后将压缩包文件解压，解压方法根据压缩包类型的不同方法有很多，我随便给一个tar.gz的：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar xvf node-v8.1.0-linux-64.tar.gz</span><br></pre></td></tr></table></figure>
<blockquote>
<p>其中，node-v8.1.0-linux-64是你的下载文件名，文件名不同这里填写的内容就不同，下面的内容也是一样的，就不一一重复了。</p>
</blockquote>
<p>解压之后，我们cd到这个目录执行node，发现已经能直接干了。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> node-v8.1.0-linux-64/bin</span><br><span class="line">./node -v</span><br><span class="line">./npm -v</span><br></pre></td></tr></table></figure>
<p>但是这样比较麻烦，每次都要进入到这个目录才能执行node和npm。那么怎样在linux里设置全局命令呢？答案是使用ln命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ln -s /root/node-v8.1.0-linux-64/bin/node /usr/<span class="built_in">local</span>/bin/node</span><br><span class="line">ln -s /root/node-v8.1.0-linux-64/bin/npm /usr/<span class="built_in">local</span>/bin/npm</span><br></pre></td></tr></table></figure>
<p>命令接收两个参数，第一个是你的node文件夹所在的位置，我图省事直接装在root下了，你改了文件位置的话这个地方就写node文件夹所在的位置的父目录即可，第二个是全局指令库位置。</p>
<p>接下来随便跳到一个目录，执行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">node -v</span><br><span class="line">npm -v</span><br></pre></td></tr></table></figure>
<p>是不是就有反应啦。</p>
<h2 id="第二种方式，通过源码编译"><a href="#第二种方式，通过源码编译" class="headerlink" title="第二种方式，通过源码编译"></a>第二种方式，通过源码编译</h2><p>还是在官网的那个下载页面下载，但是这次选择下载的是Source Code源码，还是原样ftp导入后解压，方法同上。</p>
<p>之后我们进入到源码目录中，进行编译三板斧：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">./configure</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>
<p>经过一段及其漫长的编译过程后……（make真的漫长，等了得有20分钟，可能是我云服务器配置太差 %&gt;_&lt;%）就能自动的在全局使用node和npm命令啦~</p>
<p>如果你的在服务器上不行的话，加上这一句试试：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp /usr/<span class="built_in">local</span>/bin/node /usr/sbin/</span><br></pre></td></tr></table></figure>
<p>这种方式是最推荐使用的，出问题的可能性最小，卸载修改也都很好解决。缺点是……实在是太麻烦了……</p>
<h2 id="第三种方式，通过系统安装apt-get或yum等方式安装nodejs。"><a href="#第三种方式，通过系统安装apt-get或yum等方式安装nodejs。" class="headerlink" title="第三种方式，通过系统安装apt-get或yum等方式安装nodejs。"></a>第三种方式，通过系统安装apt-get或yum等方式安装nodejs。</h2><p>我写这种方式在这里只是因为确实可以下载并安装。但我这里就不写过程了，因为这种方式下载到的安装包不仅下载慢，下载完成后的包版本还可能不是最新的，安装后还可能出现各种各样的问题，非常的不推荐使用。</p>
<p>（完）</p>
]]></content>
      
        <categories>
            
            <category> 杂项 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[flex布局初体验]]></title>
      <url>/2017/05/25/flex%E5%B8%83%E5%B1%80%E5%88%9D%E4%BD%93%E9%AA%8C/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><hr>
<p>还在为各种布局的hack方法犯愁么？还在想着网上流传的各类垂直居中存在的各种奇怪bug而影响工作体验么？还在为找不到一个合适自己的规范而疯狂造轮子么？现在，一个全新的布局解决方案规范已经展现在我们面前，它就是flex布局。只要998，各类布局完美解决方案带回家！</p>
<blockquote>
<p>2009年，W3C提出了一种新的方案—-Flex布局，可以简便、完整、响应式地实现各种页面布局。目前，它已经得到了所有浏览器的支持，这意味着，现在就能很安全地使用这项功能。</p>
</blockquote>
<p>看到没，w3c大佬亲自提出来，这权威性不用质疑了吧。</p>
<p>Flex 是 Flexible Box 的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性。任何一个容器都可以指定为Flex布局，包括行内元素。只需要设置元素的display为flex或者flex-inline即可。需要注意的是，元素设为 Flex 布局以后，它的子元素的float、clear和vertical-align属性将失效。</p>
<p>好，接下来我们就来看看，flex布局到底是个什么样的布局原理和思想。以下内容摘自阮一峰老师的<a href="http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html?utm_source=tuicool" target="_blank" rel="noopener">Flex 布局教程</a>:</p>
<blockquote>
<p>采用 Flex 布局的元素，称为 Flex 容器（flex container），简称”容器”。它的所有子元素自动成为容器成员，称为 Flex 项目（flex item），简称”项目”。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/kelekexiao123/markdown-image/master/flex-02.png" alt="flex结构图"></p>
<blockquote>
<p>容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。主轴的开始位置（与边框的交叉点）叫做main start，结束位置叫做main end；交叉轴的开始位置叫做cross start，结束位置叫做cross end。项目默认沿主轴排列。单个项目占据的主轴空间叫做main size，占据的交叉轴空间叫做cross size。</p>
</blockquote>
<p>因此啊，我们只需要关注当前元素的水平轴和垂直轴位置，即可完全定位整个元素，是不是很有道理呢？</p>
<p>具体的工具教程请自行查阅相关文档，这里我随便给个<a href="http://www.runoob.com/w3cnote/flex-grammar.html" target="_blank" rel="noopener">传送门</a>，要授人以渔喔。</p>
<h2 id="demo分割线"><a href="#demo分割线" class="headerlink" title="demo分割线"></a>demo分割线</h2><p>那我带大家做什么呢？当然是做demo啦，这种东西实用，进步最快啦。</p>
<p>先给大家上个效果图：</p>
<p><img src="https://raw.githubusercontent.com/kelekexiao123/markdown-image/master/flex-01.png" alt="demo示例"></p>
<p>这是一个自适应宽高的九个骰子图（好吧我知道骰子没有9个），大家先根据以往的经验，每个骰子应该怎样实现，再用flex布局试一次。</p>
<p>然后附上我的实现代码：<a href="https://github.com/kelekexiao123/markdown-image/blob/master/flex-test.html" target="_blank" rel="noopener">flex_demo</a></p>
<p>因为我也是新手嘛，如果大家有什么更好的想法和建议，欢迎留言或者pull request呐～</p>
]]></content>
      
        <categories>
            
            <category> CSS </category>
            
        </categories>
        
        
        <tags>
            
            <tag> css </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[解决github+Hexo的博客多终端同步问题]]></title>
      <url>/2017/05/12/%E8%A7%A3%E5%86%B3github+Hexo%E7%9A%84%E5%8D%9A%E5%AE%A2%E5%A4%9A%E7%BB%88%E7%AB%AF%E5%90%8C%E6%AD%A5%E9%97%AE%E9%A2%98/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>本文转载自：<a href="http://blog.csdn.net/Monkey_LZL/article/details/60870891" target="_blank" rel="noopener">http://blog.csdn.net/Monkey_LZL/article/details/60870891</a></p>
<blockquote>
<p>解决github+Hexo的博客多终端同步的思路是将博文内容相关文件放在Github项目中master中，将Hexo配置写博客用的相关文件放在Github项目的hexo分支上，这个是关键，多终端的同步只需要对分支hexo进行操作。</p>
</blockquote>
<p>下面是详细的步骤讲解：</p>
<h2 id="1-准备条件"><a href="#1-准备条件" class="headerlink" title="1.准备条件"></a>1.准备条件</h2><p>安装了Node.js,Git,Hexo环境<br>完成Github与本地Hexo的对接<br>这部分大家可以参考史上<a href="https://xuanwo.org/2015/03/26/hexo-intor/" target="_blank" rel="noopener">最详细的Hexo博客搭建图文教程</a></p>
<p>配置好这些，就可以捋起袖子大干一场了！</p>
<h2 id="2-在其中一个终端操作，push本地文件夹Hexo中的必要文件到yourname-github-io的hexo分支上"><a href="#2-在其中一个终端操作，push本地文件夹Hexo中的必要文件到yourname-github-io的hexo分支上" class="headerlink" title="2.在其中一个终端操作，push本地文件夹Hexo中的必要文件到yourname.github.io的hexo分支上"></a>2.在其中一个终端操作，push本地文件夹Hexo中的必要文件到yourname.github.io的hexo分支上</h2><p>在利用Github+Hexo搭建自己的博客时，新建了一个Hexo的文件夹，并进行相关的配置，这部分主要是将这些配置的文件托管到Github项目的分支上，其中只托管部分用于多终端的同步的文件，如完成的效果图所示：</p>
<p>git init  //初始化本地仓库<br>git add source //将必要的文件依次添加，有些文件夹如npm install产生的node_modules由于路径过长不好处理，所以这里没有用’git add .’命令了，而是依次添加必要文件，如下所示</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git commit -m <span class="string">"Blog Source Hexo"</span></span><br><span class="line">git branch hexo  //新建hexo分支</span><br><span class="line">git checkout hexo  //切换到hexo分支上</span><br><span class="line">git remote add origin git@github.com:yourname/yourname.github.io.git  //将本地与Github项目对接</span><br><span class="line">git push origin hexo  //push到Github项目的hexo分支上</span><br></pre></td></tr></table></figure>
<p>完成之后的效果图为:</p>
<p><img src="https://raw.githubusercontent.com/kelekexiao123/markdown-image/master/sync-hexo-01.png" alt="hexo分支"></p>
<p>这样你的github项目中就会多出一个Hexo分支，这个就是用于多终端同步关键的部分。</p>
<h2 id="3-另一终端完成clone和push更新"><a href="#3-另一终端完成clone和push更新" class="headerlink" title="3.另一终端完成clone和push更新"></a>3.另一终端完成clone和push更新</h2><p>此时在另一终端更新博客，只需要将Github的hexo分支clone下来，进行初次的相关配置</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> -b hexo git@github.com:yourname/yourname.github.io.git  //将Github中hexo分支<span class="built_in">clone</span>到本地</span><br><span class="line"><span class="built_in">cd</span>  yourname.github.io  //切换到刚刚<span class="built_in">clone</span>的文件夹内</span><br><span class="line">npm install    //注意，这里一定要切换到刚刚<span class="built_in">clone</span>的文件夹内执行，安装必要的所需组件，不用再init</span><br><span class="line">hexo new post <span class="string">"new blog name"</span>   //新建一个.md文件，并编辑完成自己的博客内容</span><br><span class="line">git add <span class="built_in">source</span>  //经测试每次只要更新sorcerer中的文件到Github中即可，因为只是新建了一篇新博客</span><br><span class="line">git commit -m <span class="string">"XX"</span></span><br><span class="line">git push origin hexo  //更新分支</span><br><span class="line">hexo d -g   //push更新完分支之后将自己写的博客对接到自己搭的博客网站上，同时同步了Github中的master</span><br></pre></td></tr></table></figure>
<h2 id="4-不同终端间愉快地玩耍"><a href="#4-不同终端间愉快地玩耍" class="headerlink" title="4.不同终端间愉快地玩耍"></a>4.不同终端间愉快地玩耍</h2><p>在不同的终端已经做完配置，就可以愉快的分享自己更新的博客<br>进入自己相应的文件夹</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git pull origin hexo  //先pull完成本地与远端的融合</span><br><span class="line">hexo new post <span class="string">" new blog name"</span></span><br><span class="line">git add <span class="built_in">source</span></span><br><span class="line">git commit -m <span class="string">"XX"</span></span><br><span class="line">git push origin hexo</span><br><span class="line">hexo d -g</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> git </category>
            
        </categories>
        
        
        <tags>
            
            <tag> git </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[es6学习笔记]]></title>
      <url>/2017/04/16/es6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><hr>
<p>最近在尝试学习新框架，感觉学习曲线异常的陡峭，全然没有当时学习bootstrap和jquery的顺畅感觉。后面仔细想来，自己应该是缺了一些基础知识没有补上来，才会导致框架学习遇到了极大的阻力。那自己的知识栈到底缺失了哪一块呢？没错，就是面向未来的javascript语法————ES6。</p>
<p>那么现在开始恶补吧，还不算晚。我将我的学习过程记录下来，为自己做notes，也与各位分享。</p>
<hr>
<p>这个学习笔记我决定由浅入深，先说说es6中最有用、最常用的一些新特性，并举例子介绍它们的特点，所举例子大部分参考自阮一峰老师的 <a href="http://es6.ruanyifeng.com/" target="_blank" rel="noopener">《ECMAScript 6 入门》</a>。这本书可是es6入门的一本佳作，更难能可贵的是还获得了开源许可，推荐大家一读。</p>
<p>好了言归正传，这一期我准备先来介绍es6新增的用来定义变量的新命令。</p>
<hr>
<h2 id="let命令"><a href="#let命令" class="headerlink" title="let命令"></a>let命令</h2><p>只要是听过es6大名的人，第一个想到的应该就是let命令，因为它的出现一举解决了es5时代的许多莫名其妙的变量提升，变量污染的问题。</p>
<p>我们都知道，es5以前的规范中，javascript并没有作用域作用块的概念，唯一能够限制使用var定义的变量不溢出的块只有函数包裹的块。其他的任何方式都很容易一个不小心就把局部变量泄漏了出去。比如这样：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(a)  <span class="comment">//ReferenceError: a is not defined</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> b = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(b);  <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> c = <span class="number">0</span>; c &lt; <span class="number">5</span>; c++)&#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(c)  <span class="comment">// 5</span></span><br></pre></td></tr></table></figure>
<p>但是自从引入了let命令，js就有了作用域和代码块，我们可以定义只在块作用域(使用花括号括起来的作用域，包括函数、对象等)中作用的变量了。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> a = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(a)  <span class="comment">//ReferenceError: a is not defined</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> b = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(b);  <span class="comment">//ReferenceError: b is not defined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> c = <span class="number">0</span>; c &lt; <span class="number">5</span>; c++)&#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(c)  <span class="comment">//ReferenceError: c is not defined</span></span><br></pre></td></tr></table></figure>
<p>这就是let的特性。</p>
<hr>
<p>那么有了这个新的定义变量的命令，我们就能解决许多从前我们极其痛恨过的js缺陷了。</p>
<ol>
<li>妈妈再也不用担心我的变量提升</li>
</ol>
<p>我们都知道，var命令会发生”变量提升“现象，即变量可以在声明之前使用，值为undefined。而let命令改变了语法行为，它所声明的变量一定要在声明后使用，否则报错。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(a);  <span class="comment">//undefined</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(b);  <span class="comment">//ReferenceError: b is not defined</span></span><br><span class="line"><span class="keyword">let</span> b = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p>写很长的代码时，经常会遇到很尴尬的事儿：忘记自己定义过了一个变量导致重复定义，或在变量声明前就使用这个变量，从而导致意料之外的行为。</p>
<p>我们来看一道超级经典的面试题,var a=a 的运算结果：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = a;</span><br><span class="line"><span class="built_in">console</span>.log(a);  <span class="comment">//undefined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> b = b;</span><br><span class="line"><span class="built_in">console</span>.log(b);  <span class="comment">//ReferenceError: b is not defined</span></span><br></pre></td></tr></table></figure>
<p>由于var定义的变量存在变量提升，因此a变量被提前定义，值为undefined。再由js语法中运算符的计算顺序是从右到左，因此在右侧的a先进行运算，此时a的值为undefined，因此左侧的a被赋值为undefined。</p>
<p>对这么简单的代码，里面包含的过程就是这么复杂。</p>
<p>但是没必要啊，粗略一看这样的赋值行为就是不合理的，怎么能在没声明变量前就先使用了这个变量呢。于是let命令告诉了我们，再也不会有这样的事情了。</p>
<hr>
<ol>
<li>解决闭包缺陷变得so easy</li>
</ol>
<p>还是让我们再来看一道超级经典的面试题，求以下a数组中任意一个项目的值：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">    (a[i] = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;)();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a[<span class="number">2</span>]());  <span class="comment">//5</span></span><br></pre></td></tr></table></figure>
<p>很明显我们看到，这是一个由闭包引发的灾难，内部函数持续保持对i的引用导致最后取值的时候获得的都是已经被循环完成后的值了。</p>
<p>那么以前我们会怎么解决呢？很简单，会再加一层闭包，保持对当前i的引用，并立即执行掉：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">    (<span class="function"><span class="keyword">function</span>(<span class="params">i</span>)</span>&#123;</span><br><span class="line">        a[i] = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a[<span class="number">2</span>]());  <span class="comment">//2</span></span><br></pre></td></tr></table></figure>
<p>或者干脆将函数移出循环体：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun</span>(<span class="params">i</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">    a[i] = fun(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a[<span class="number">2</span>]());  <span class="comment">//2</span></span><br></pre></td></tr></table></figure>
<p>看看，为了解决个这么小的问题，这代码一下就变得复杂了起来。</p>
<p>有了let命令，这一切问题都不存在了：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">    (a[i] = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;)();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a[<span class="number">2</span>]());  <span class="comment">//2</span></span><br></pre></td></tr></table></figure>
<h2 id="const命令"><a href="#const命令" class="headerlink" title="const命令"></a>const命令</h2><p>const命令又是另外一个用来声明变量的常用命令。const声明一个只读的常量。一旦声明，常量的值就不能改变。</p>
<p>这个命令我感觉尤其在nodejs里面使用的多，包括定义端口呀、定义服务指令呀都需要用到它。</p>
<p>对于这个命令，我们只需要知道一点：</p>
<blockquote>
<p>const实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址不得改动。</p>
</blockquote>
<p>也就是说，我们不能改变使用const定义的基本数据类型，但定义的函数、数组、对象等引用类型里面的值我们还是可以随意更改的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="number">1</span>;</span><br><span class="line">a = <span class="number">2</span>;  <span class="comment">//TypeError: Assignment to constant variable.</span></span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> b = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line">b[<span class="number">0</span>] = <span class="number">2</span>;</span><br><span class="line">b.push(<span class="number">3</span>);</span><br><span class="line"><span class="built_in">console</span>.log(b);  <span class="comment">//[ 2, 2, 3 ]</span></span><br></pre></td></tr></table></figure>
<p>如果你连这点权利也不让这个变量使用的话，那真是太没人性了！<br>（悄悄的告诉你，使用Object.freeze()函数吧，他会锁死引用对象，不让其中的数据增删改。：）</p>
]]></content>
      
        <categories>
            
            <category> JavaScript </category>
            
        </categories>
        
        
        <tags>
            
            <tag> es6 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[js学习笔记梳理(2)]]></title>
      <url>/2017/02/20/js%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E6%A2%B3%E7%90%86(2)/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><hr>
<p>上一节我梳理了一下闭包的概念，这些天各种学校的事情挺忙的，直到现在才有空余时间来写写博客这样杀时间的事儿。这一次整理一下原型链的那些事儿。</p>
<hr>
<p>大家都知道在JavaScript的世界里，一切皆对象。而我们又知道，JavaScript并不是完全的一门 OOP（面向对象编程）的语言，它是一门面向原型链编程的语言。综上我们可以得出，其实原型也是一个对象。这对我接下来要讲的内容的理解有至关重要的作用。</p>
<p>OOP中一个最重要的特性就是继承，那JavaScript作为一门完全独立的语言自然也需要有这一特性，而JavaScript本身并没有类继承或者接口继承相关的概念，我们需要使用原型链来模拟这一过程。不多说，先上一个例子。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Father</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">Father.prototype = &#123;    <span class="comment">//Father的原型</span></span><br><span class="line">    age: <span class="number">50</span>,</span><br><span class="line">    home: [<span class="string">'Beijing'</span>, <span class="string">'Shanghai'</span>]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> father = <span class="keyword">new</span> Father();</span><br><span class="line">Person.prototype = father; <span class="comment">//Person 的原型为 Father</span></span><br><span class="line"><span class="comment">// 这样写的好处是子类如果更改了prototype，那么更改的东西也是附加到father这个实例对象上的</span></span><br><span class="line"><span class="comment">// 如果你直接写Person.prototype = Father.prototype，</span></span><br><span class="line"><span class="comment">// 那你对 Person 的 prototype 的任何修改都会同时修改 Father 的 prototype</span></span><br></pre></td></tr></table></figure>
<p>这个例子中，我定义了一个父类构造函数Father，和一个子类构造函数Person。至于为什么用构造函数这么奇怪的模式来定义一个类的原因我认为完全可以下次再开一篇专门的文章来阐述，简单来说这个构造函数模式是JavaScript生成自定义原型链的一种模式。</p>
<p>好，那么接下来，重点来了。这里使用了父类构造函数的prototype，这是个什么东东呢？在JavaScript里，对每一个函数，都自动会继承一个prototype的属性，指向了构造函数所继承的原型对象。</p>
<p>我之前说过，万物皆对象。函数当然也是一个对象，它当然也需要继承另一个对象，那么被函数对象继承的对象，就叫原型对象，在例子里面，他就叫做Father.prototype。</p>
<p>原型对象，首先是一个对象呀。因此我在重写父类构造函数的原型对象的时候使用了字面量模式，也就是{……}的方法来指定一个对象。当然，你要这么书写也是对的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Father.prototype.age = <span class="number">50</span>;</span><br><span class="line">Father.prototype.home = [<span class="string">'Beijing'</span>, <span class="string">'Shanghai'</span>];</span><br></pre></td></tr></table></figure>
<p>当然，它们之间会有一些差别，但就为对象赋值的情况他们的作用是等效的。</p>
<p>在之后呢，我们为父类创建了一个实例，并将子类构造函数的原型对象指向了这个实例，到此继承原型链完成。</p>
<p>啊啊啊不要问我为什么要这样继承了，这样做并不奇怪。首先我们知道函数的 prototype 必定指向一个obj对象，那么构造函数显然不能担当这一职责，只有被实例化的对象才能成为子类的原型对象。这里可以填入的对象有两个，一个是father，另一个是Father.prototype。那为什么不是后面这个呢？试试就知道了。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Person.prototype = Father.prototype;</span><br></pre></td></tr></table></figure>
<p>这行代码一敲完我就觉得非常的搞笑了，按自然语言的理解来看看，你的父亲等于你父亲的父亲！？？那你爸是你表哥咯？实际上呢，这样子的赋值语句也经常用到，只不过含义完全不同，这是继承自同一原型的两个不同子类，相当于兄弟节点，这好理解吧？</p>
<p>这里要讲的是子类继承，因此接下来子类的构造函数的prototype自然也指向这个被实例化的原型对象。JavaScript的语言逻辑就是这么奇怪又好有道理的样子。</p>
<p>好，接下来我要给子类实例化两个对象出来，分别是我和我弟弟。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">'成龙'</span>);</span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person(<span class="string">'成风'</span>);</span><br></pre></td></tr></table></figure>
<p>前戏就讲到这里，接下来我们进入正题。基于原型到底有哪些特性。</p>
<hr>
<h2 id="1-简单赋值不会改变原型以及该对象的兄弟对象的属性，实例不能改变原型的基本值属性。"><a href="#1-简单赋值不会改变原型以及该对象的兄弟对象的属性，实例不能改变原型的基本值属性。" class="headerlink" title="1.简单赋值不会改变原型以及该对象的兄弟对象的属性，实例不能改变原型的基本值属性。"></a>1.简单赋值不会改变原型以及该对象的兄弟对象的属性，实例不能改变原型的基本值属性。</h2><p>还是先举一个例子，比如我肯定没有我爸年纪那么大，因此我继承了所有属性后，我还应该要自己有一个年龄属性覆盖上去。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">person1.age = <span class="number">20</span>;</span><br><span class="line"><span class="built_in">console</span>.log(person1.age);    <span class="comment">//20</span></span><br><span class="line"><span class="built_in">console</span>.log(person1.__proto__.age);   <span class="comment">//50</span></span><br></pre></td></tr></table></figure>
<p>子类改变了自己类内的属性（实质是覆盖，使用delete删去该属性后，仍然继承父类的值），但是这并不会影响父类中该属性的值。</p>
<p>这很好理解吧，你虽然天生遗传了你爸的基因，但是你自己上课外班学会了唱歌跳舞你爸总不会就自然学会了吧？</p>
<p>ps：这里说一说”<strong>proto</strong>“这个属性，ECMAScript5中叫它[prototype]，是每一个被实例化的对象都会被继承的属性，它的指向与该实例化对象的构造函数的prototype的指向相同，指向原型对象。</p>
<hr>
<h2 id="2-原型中引用类型的属性是共享的，实例对象能够修改原型对象中引用类型对象的属性"><a href="#2-原型中引用类型的属性是共享的，实例对象能够修改原型对象中引用类型对象的属性" class="headerlink" title="2.原型中引用类型的属性是共享的，实例对象能够修改原型对象中引用类型对象的属性"></a>2.原型中引用类型的属性是共享的，实例对象能够修改原型对象中引用类型对象的属性</h2><p>引用类型是什么呢，这里涉及到js的基础知识了，在JavaScript中，数据类型一共有7种，分别是：Number, String, Boolean, Undefined, Null, Object, Function。其中基本数据类型共5种：Number, String, Boolean, Undefined, Null。而剩下的统称为引用类型，包括obj对象，函数和数组。究其原理呢，是因为引用类型并不实际占用栈内存而只是其中的基本类型数据占用，引用类型仅用堆内存提供指针指向他们，于是就有了一个非常有趣的现象：基本数据类型永远无法被改变，而引用类型可以，原因就是引用类型只需要修改指针，指向另外一个基本类型数据就可以了呀。</p>
<p>扯远了，总而言之，引用类型并不是保存值的，而只是一个指针堆，或者说是基本数据的引用堆，因此我们修改实例对象中的引用类型对象的时候，原型对象中引用类型对象的属性也会同时被修改，因为他们本来就指向的同一个内存块嘛。</p>
<p>还是举一个例子加深一下理解。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(person1.home);    <span class="comment">//[ 'Beijing', 'Shanghai' ]</span></span><br><span class="line">person1.home[<span class="number">0</span>] = <span class="string">'Shenzhen'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(father.home);    <span class="comment">//[ 'Shenzhen', 'Shanghai' ]</span></span><br><span class="line"><span class="built_in">console</span>.log(person1.home);   <span class="comment">//[ 'Shenzhen', 'Shanghai' ]</span></span><br></pre></td></tr></table></figure>
<p>本来啊，你们一家都住在北京，但是你长大了，跑到深圳去工作了，还在那里买了房子住下了，于是你的住址被迁移到了深圳。但是同时，你必须要和爸妈住在一起，拥有相同的住址（引用类型嘛，指向同一个地址位置），因此你爸也吧户口改了，迁移到了深圳。</p>
<p>还是不能理解？哎，我也觉得有点牵强，还是不能随便类比，那还是来个基础编程吧。我们如果要让person1拥有一个home的数组属性，并且它的第0号元素为’Shenzhen’，该怎么办呢？</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person1 = &#123;&#125;;</span><br><span class="line">person1.home[<span class="number">0</span>] = <span class="string">'Shenzhen'</span>;</span><br></pre></td></tr></table></figure>
<p>这样行得通吗？你可以自己试试，显然是不可以的，这里会报错：’home’ not defined。它连home这个属性都还没有呀，怎么能给home的第一个元素赋值呢？所以我们应该这样写：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person1 = &#123;&#125;;</span><br><span class="line">person1.home = [];</span><br><span class="line">person1.home[<span class="number">0</span>] = <span class="string">'Shenzhen'</span>;</span><br></pre></td></tr></table></figure>
<p>先把home属性给它定义出来自然就不会有问题啦。其实呀，这跟我们的问题是一样一样的。person1中，并没有一个名为home的属性，因此person1.home[0]是不行的。</p>
<p>至于为什么没有报错呢，是因为js的原型链向上搜索机制：如果查找一个对象的属性没有找到，搜索会继续在继承的对象中搜索，如果还没有则逐级向上搜索直到找到为止。而此时，虽然person1中没有这个属性，但它继承的父类中有home这个属性，于是系统会认为找到了这个属性，并随着你的赋值语句更改了父类中该属性的值。</p>
<p>再来举一个例子。我们开始说了，给子类改写属性的实质是一种覆盖。删除实例的属性之后，就会取消了子类的属性覆盖，这个时候再需要调用该对象的这个属性时，就会从原型链上一层一层找到头，直到找到为止。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(person1.home);    <span class="comment">//[ 'Shenzhen', 'Shanghai' ]</span></span><br><span class="line"><span class="keyword">delete</span> person1.home;</span><br><span class="line"><span class="built_in">console</span>.log(person1.home);    <span class="comment">//[ 'Beijing', 'Shanghai' ]</span></span><br></pre></td></tr></table></figure>
<p>累死了，现在总该明白这西方的一套是怎么回事了吧？如果这样还不明白的话，我也只能说“不了不了“。</p>
<hr>
<h2 id="3-改写构造函数的原型，改写的属性能够动态反应到实例化的对象中"><a href="#3-改写构造函数的原型，改写的属性能够动态反应到实例化的对象中" class="headerlink" title="3.改写构造函数的原型，改写的属性能够动态反应到实例化的对象中"></a>3.改写构造函数的原型，改写的属性能够动态反应到实例化的对象中</h2><p>在定义父类完毕后，你突然想补充一点，比如说：我弟和我都是男的啊！你爸那一代身份证可能没考虑到性别这一属性，那你爸和你以及你弟怎么办呢,总不能性别模糊吧？</p>
<p>办法还是有的，就是改写子类的原型对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Person.prototype.sex = <span class="string">'male'</span>;</span><br><span class="line"><span class="comment">// 等同于father.sex = 'male'，也等同于person1.__proto__.sex = 'male'</span></span><br><span class="line"><span class="comment">// 这里不能写成：Father.sex = 'male'; 这是因为面向对象编程的规则：对象（实例）才是属性的拥有者。</span></span><br><span class="line"><span class="built_in">console</span>.log(person1.sex);   <span class="string">'male'</span></span><br><span class="line"><span class="built_in">console</span>.log(father.sex);    <span class="string">'male'</span></span><br></pre></td></tr></table></figure>
<p>其实呀，这个Person.prototype就是 father，因此呢，你如果非要定义father.sex = ‘male’ 也不是不可以，仅在此题中实现的效果是相同的。但是这不符合JavaScript规范，也是普遍面向对象编程的规则：对象（实例）才是属性的拥有者。</p>
<p>改写原型对象后呢，子类也会动态地继承这些属性，因此这一招改原型大法还是非常的常用的。</p>
<hr>
<h2 id="4-重写构造函数的原型，使子类继承一个新的原型"><a href="#4-重写构造函数的原型，使子类继承一个新的原型" class="headerlink" title="4.重写构造函数的原型，使子类继承一个新的原型"></a>4.重写构造函数的原型，使子类继承一个新的原型</h2><p>比如呀，你有一个同母异父的弟弟，他的什么东西都和你跟你爸爸不像，显然啊，他跟你爸并没有什么血缘关系嘛，因此它没有任何属性是从你爸那里继承的呀。</p>
<p>重写原型其实很简单，直接对Person.prototype附一个不同字面量对象即可。由于重写原型会使得原有的继承全部更换，因此不是特殊用途的情况下使用的很少。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Person.prototype = &#123;</span><br><span class="line">    age: <span class="number">40</span>,</span><br><span class="line">    home: [<span class="string">'Guangzhou'</span>, <span class="string">'Changsha'</span>]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person3 = <span class="keyword">new</span> Person(<span class="string">'黄龙'</span>);</span><br><span class="line"><span class="comment">// 这个时候Person的原型已经完全变成了另一个对象，于是我连这个家伙的姓氏都改掉了~</span></span><br><span class="line"><span class="built_in">console</span>.log(person3.home);</span><br><span class="line"><span class="built_in">console</span>.log(person3.age);</span><br><span class="line"><span class="built_in">console</span>.log(person1.home);</span><br><span class="line"><span class="built_in">console</span>.log(person1.age);</span><br></pre></td></tr></table></figure>
<p>你这个没有什么血缘关系的弟弟有一个更年轻的爸爸，住址也跟你完全不同，其实跟你完全就是两个世界的人了嘛，于是我连这个家伙的姓氏都改掉了~ </p>
<hr>
<p>唔，大概我能总结出来的特性就这么多啦，想到再补充吧~</p>
]]></content>
      
        <categories>
            
            <category> JavaScript </category>
            
        </categories>
        
        
        <tags>
            
            <tag> es5 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[js学习笔记梳理(1)]]></title>
      <url>/2017/02/10/js%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E6%A2%B3%E7%90%86(1)/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><hr>
<p>最近在梳理关于js一些原理层次的东西，感觉学的有点乱，是时候整理沉淀一下记录成文字了。在我看来，最难理解的核心就两点，一是对闭包的理解，二是对原型链的深入。在这里我先说说闭包。</p>
<hr>
<p>大家都知道闭包是JavaScript的难点，首先我们得知道什么是闭包？</p>
<p>《JavaScript高级程序设计)》中是这样说的：</p>
<blockquote>
<p>闭包就是指有权访问另一个函数中的变量的函数。</p>
</blockquote>
<p>《JavaScript权威指南》这样定义：</p>
<blockquote>
<p>函数对象可以通过作用域链相互关联起来，函数体内部的变量都可以保存在函数作用域内，这种特性在计算机科学文献中成为“闭包”。</p>
</blockquote>
<p>简单的来说呢，这个牵扯到JavaScript作用域的问题。</p>
<p>在es6以前，js其实只有一种作用域，那就是函数级作用域，也就是说任何的私有变量或者函数必须包裹在函数内才能导致不产生全局的变量污染。当然es6以后出现的let（）也有这个功能了，关于let的用法可参考<a href="http://es6.ruanyifeng.com/#docs/let" target="_blank" rel="noopener">《ECMAScript 6 入门》中第二章</a>。这里暂且按住不表。</p>
<p>那么闭包是什么呢，闭包简单来说就是一个特殊的函数，<strong>能在自己的作用域里调用其他函数中的私有变量或者私有函数的特殊函数</strong>。通俗的来讲就是闭包就还一个嵌套在其他函数里的函数，其中可以引用外部函数的参数和变量，这些参数和变量不会被js的垃圾回收机制自动回收，且变量和参数不会对外部的作用域造成污染。</p>
<p>说完了是什么，那么为什么要创建闭包，它又有什么功能呢？</p>
<p>在我看来好处有三点：</p>
<h2 id="1-提供访问函数中的私有变量的入口"><a href="#1-提供访问函数中的私有变量的入口" class="headerlink" title="1.提供访问函数中的私有变量的入口"></a>1.提供访问函数中的私有变量的入口</h2><p>举个例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Obj</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> privateVar = <span class="number">1</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">privateFunc</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> privateVar;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//特权方法（闭包访问私有变量和私有函数并传递给外界）</span></span><br><span class="line">    <span class="keyword">this</span>.publicFunc = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        privateVar++;</span><br><span class="line">        <span class="keyword">return</span> privateFunc();</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> Obj();</span><br><span class="line"><span class="built_in">console</span>.log(obj.publicFunc());</span><br></pre></td></tr></table></figure>
<p>这里就可以看到一个闭包就能把函数中的私有变量以及私有函数的值取出到了外部作用域。</p>
<h2 id="2-作用域隔离"><a href="#2-作用域隔离" class="headerlink" title="2.作用域隔离"></a>2.作用域隔离</h2><p>闭包的另一个作用是防止变量污染，限制向全局作用域中添加过多的变量和函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">    (<span class="function"><span class="keyword">function</span> <span class="title">fun2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">        a += <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">console</span>.log(a);</span><br><span class="line">    &#125;)();</span><br><span class="line">    <span class="built_in">console</span>.log(a);</span><br><span class="line">&#125;</span><br><span class="line">fun1();</span><br></pre></td></tr></table></figure>
<p>我们可以看到，在fun2()这个闭包里定义的新的变量并进行更改时，并不会对外部变量造成污染。</p>
<h2 id="3-在循环中包含函数且该函数中使用了遍历数据"><a href="#3-在循环中包含函数且该函数中使用了遍历数据" class="headerlink" title="3.在循环中包含函数且该函数中使用了遍历数据"></a>3.在循环中包含函数且该函数中使用了遍历数据</h2><p>记得在知乎上看到一道面试题，地址搜不到了，大体说是要利用循环给一个数组绑定数组索引对应的值，我先列一个错误的写法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createFunctions</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> result = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i &lt; <span class="number">5</span>; i++)&#123;</span><br><span class="line">        result[i] = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> funcs = createFunctions();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i &lt; funcs.length; i++)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(funcs[i]());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样并不能得到想要的结果，因为result[i]绑定的是一个函数，但是当场并不执行，等到console.log()的时候才想到去执行，并调用i，但此时i早已结束了循环，此时的值为5，因此，输出为5个5，而不是0-4。</p>
<p>那么需要怎么改才能达到想要的结果呢，这个时候，闭包闪亮登场了。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_createFunctions</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> result = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i &lt; <span class="number">5</span>; i++)&#123;</span><br><span class="line">        (<span class="function"><span class="keyword">function</span>(<span class="params">i</span>) </span>&#123;</span><br><span class="line">            result[i] = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;)(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> funcs = _createFunctions();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i &lt; funcs.length; i++)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(funcs[i]());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>加一个 IIFE，并将遍历参数传了进去，一切都不一样了，为什么呢？</p>
<p>这就又得提到垃圾回收机制了，由于闭包函数传入了外部函数的参数变量i，因此在var funcs = _createFunctions();这一句之后_createFunctions()被销毁，但是函数变量i不会随着外部函数_createFunctions()的销毁而回收，因为闭包能够保持对当前i的引用，于是在真正调用时，执行闭包中的i为当时循环遍历到的数值，从而输出了0-4.</p>
<p>最后，我们再来做道课后习题来巩固一下吧。<br>更改下面的代码，使得它能够每个一秒分别输出0-4:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">  &#125;, <span class="number">1000</span> * i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我想到了两个利用闭包的解法</p>
<p>法一：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">fun2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        (<span class="function"><span class="keyword">function</span>(<span class="params">i</span>) </span>&#123;</span><br><span class="line">            setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="built_in">console</span>.log(i);</span><br><span class="line">            &#125;,<span class="number">1000</span>*(i+<span class="number">1</span>));</span><br><span class="line">        &#125;)(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>
<p>法二：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">_fun2</span>(<span class="params">i</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">5</span>) &#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(i);</span><br><span class="line">            _fun2(++i);</span><br><span class="line">        &#125;, <span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)(<span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<p>原理我就不细说啦，自己琢磨琢磨会有更多收获的哦。</p>
<hr>
<p>啊，第一次尝试markdown写博客，花了好多时间啊，那原型链的知识就留到下次在整理吧。</p>
]]></content>
      
        <categories>
            
            <category> JavaScript </category>
            
        </categories>
        
        
        <tags>
            
            <tag> es5 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[jQuery判断及修改checked状态的方法]]></title>
      <url>/2017/01/05/jQuery%E5%88%A4%E6%96%AD%E5%8F%8A%E4%BF%AE%E6%94%B9checked%E7%8A%B6%E6%80%81%E7%9A%84%E6%96%B9%E6%B3%95/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><hr>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.attr(<span class="string">"checked"</span>): <span class="comment">//1.6+返回: "checked"或"undefined"; 1.5以下返回: true/false</span></span><br><span class="line">.prop(<span class="string">"checked"</span>): <span class="comment">//1.6+: true/false</span></span><br><span class="line">.is(<span class="string">":checked"</span>): <span class="comment">//所有版本: true/false，注意冒号</span></span><br></pre></td></tr></table></figure>
<p>jQuery 赋值 checked 的几种写法:</p>
<p>所有的jQuery版本都可以这样赋值:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">"#cb1"</span>).attr(<span class="string">"checked"</span>,<span class="string">"checked"</span>);</span><br><span class="line">$(<span class="string">"#cb1"</span>).attr(<span class="string">"checked"</span>,<span class="literal">true</span>);</span><br></pre></td></tr></table></figure>
<p>jquery1.6+: prop的4种赋值:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">"#cb1″).prop("</span>checked<span class="string">", true);  </span></span><br><span class="line">$("#cb1″).prop(&#123; checked: true &#125;); </span><br><span class="line">$(<span class="string">"#cb1″).prop("</span>checked<span class="string">", function() &#123;</span></span><br><span class="line"><span class="string">  return true; //函数返回 true 或 false</span></span><br><span class="line"><span class="string">&#125;);</span></span><br><span class="line">$("#cb1″).prop("checked", "checked");</span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> 常见问题集锦 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> jQuery </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[代码重构之我见]]></title>
      <url>/2016/10/16/%E4%BB%A3%E7%A0%81%E9%87%8D%E6%9E%84%E4%B9%8B%E6%88%91%E8%A7%81/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><hr>
<p>最近在看一些软件工程和构建方面的书籍。俗话说，书读百遍，其义自见，看得多了，自然也就有一些知识可以拿得出手分享一二了。</p>
<p>由于我在写代码的过程中往往很追求代码的优雅和简洁，因此我着重阅读了代码重构方面的知识，现在对代码的重构也算略有体会了。接下来我将结合我所吸收到的知识与我自己的一些理解和观点来阐述一下代码重构的艺术。</p>
<hr>
<p>先来说说代码重构是什么吧。</p>
<p>重构一般是指把代码优化，便于再修改和开发的一种过程。重构并不是说，我把原来的代码全部推翻，重改架构，不是的，那叫重写，不叫重构。重构更像是装修，重写是推倒重盖，不知道这样解释是不是比较形象了呢？</p>
<hr>
<p>那我们为什么需要重构呢？</p>
<p>一般的底层码农编程理念不够扎实，加上，分工合作的原因，总会写出一些烂代码，难以修改，这才需要进行重构。</p>
<p>我要着重提出的是：重构不是万能的，更不是用来装逼的！接下来我想解释一下在什么时候我们才需要进行重构，以及重构究竟是为了做什么的。</p>
<p>因为我看到网上总是有很多人标榜我重构代码几千行改到几行之类的，我觉得那是噱头，为了装逼而装逼的。重构的首要宗旨并不是为了简化代码的，重构的本质是为了清除烂代码的，只是在代码层面做修改，并不触动架构。也就是说，你原来的架构就很烂的话，重构并不会有所改善重构以后，代码效率并不会比原来过程型的代码快，甚至更慢。</p>
<hr>
<p>那么对于需要重构的代码，我们该如何进行重构呢？</p>
<p>重构最简单的思路一般有两个：分，合。</p>
<p>分指的是把现有的业务逻辑简化，并不是实际简化，而是从代码结构上简化比如我一个功能需要1000行代码，干的10个事情，现在我把这10个事情都分出去，做成10个模块，然后做一个封装，这样，最上层的代码量就急剧减少了，逻辑也变的简单了。但是这不是随便分的，一般一个基础的底层处理的模块，一个模块只做一件事。什么是底层处理模块，比如分割字符串这个功能，就是底层模块，可以让任意模块调用，而且比较简单，这就是基础底层模块的要求。由于把一些公共的模块分离了，代码中直接调用这些模块，简化了代码，也减少了代码量。一般来说，代码如果超过一屏，就考虑尽量分离模块了。</p>
<p>一般说来，重构都是基于面向对象框架下的。因为一般过程型的代码，优化比较麻烦，不是面向对象的，分解起来会比较麻烦。一般来说，分层分的越细，结构越明晰，但是代码效率越差，因为继承封装可能比较多的缘故，所以一般要做一个平衡。公共调用的模块或者类，使用比较多的模块，一定要分出来。</p>
<p>举个例子吧，比如我要写一个自定义的格式化时间的函数，能够把一系列的时间函数，能用到的集合在一个类里。比如格式化时间函数，比如计算时间差的函数，如果就是孤单的一个函数，可以放到一个基类里。我觉得最好所有的函数最好都封装在类中，一个没有单独函数的框架，重用性一般能大大提高。基于类的好处，是可以轻易定位函数所在的位置，一般类名和文件名是需要保持一致的，看到类的前缀，就可以定位到类的名称和文件，但是如果是单独的函数，定位起来就比较麻烦。</p>
<p>重构的好处和意义，就是帮助程序拥有一套良好的规范。我们都知道，一个好的框架，需要有公共函数，还需要有私有函数，不然容易产生函数名重复等种种问题。一直执行一套良好的规范的程序，一定是比较容易维护和比较容易看懂的。不遵守规范，即使重构，难度也比较大，一些质量相当差的代码甚至没有改的价值，重构纯属浪费时间，所以重构前，需要判断，代码用不用重构，太差的话不如重写了。</p>
<p>极限编程流派中有一个观点，就是代码质量不重要，开发速度最重要。我也觉得这样是有道理的，因为先做出成果再debug给我们的正向激励是大得多的。并且就我现在所处的学校环境来说，同学们写出来的代码还不至于会发生差到只能重写如此这般的惨剧，有一些代码甚至还十分的巧妙和效率。但是经过我上网浏览到的一些奇葩段子，我才发现，原来世界这么大。</p>
<p>说有一个程序员用一天的时间写了一个刷单程序，需要展示出需要刷单的列表。这个程序并不复杂，但不知道为什么，执行起来特别慢，一个页面需要几十秒甚至刷新不出来<br>然后贴出了他的代码。我看了下代码，这个程序一次刷新就需要嵌套查询数据库上万次！一个列表查询上万次！列表要显示需要刷单的人信息，需要显示已经已经接单的人信息，有一些附加信息吧，结果，刷单的表没有冗余，需要关联用户表，他都是嵌套查询，所以刷单列表里嵌套查询用户信息，用户等级又是一个表，所以用户信息里嵌套查询等级名称，这样几十种数据嵌套来嵌套去，居然一个页面查询上万次！</p>
<p>高尔基曾经说过：好程序的优点大致相同，烂程序的缺点也大致相同。（不他并没有这么说过【捂脸】）比如：</p>
<p>1.不断重复的代码。</p>
<p>举个例子，对数据库的CURD操作，纯过程代码，如果没有分离出模块来，那每调用一次就需要再写一次相同的代码。而这还不是最关键的。我改了一处的代码，势必要改另外所有地方的代码，因为逻辑一致啊。但是分离出去模块后，改一处就可以了，减少了工作量，代码量也减少了。</p>
<p>2.人为的刻意复杂</p>
<p>很多人爱秀技术爱装逼，把一个逻辑搞的特别复杂。我继续拿添加商品的逻辑做例子吧。添加商品，需要添加id，需要添加搜索条件，需要同步更新缓存，需要生成页面，把这一堆逻辑写到一个页面里，成百上千行代码，怕不怕？尤其是多层嵌套的if else，嵌套上三层五层，估计看着就晕。</p>
<p>再说一个段子吧：有个程序员看到一段代码，大骂起来，这是哪个傻逼写的代码啊，这么乱啊！回头仔细看了下，是自己写的。</p>
<p>有的时候这确实是个真命题：你写的代码你不一定能看的懂。</p>
<p>对于如何针对嵌套，如if else之类的，去优化代码结构，，我自己是这么做的：单层的if else，直接写就可以，短逻辑直接用三元表达式（a?b:c），而不是if。长一点的简单逻辑，直接用数组表示。再复杂一点的，用switch语句，至于更复杂的，可以利用函数或者设计模式的方式解决。总的来说，嵌套一般不超出2层，一旦超出，就必须引入其他解决方式。要养成“看到if就不舒服的病”。<br>分的模块多了，有的时候怕也是不好找，所以必须要让每个模块名称都是望文知意。必须要养成英文单词的驼峰式命名或者其他统一的命名规范，绝对不可以用拼音或者是简拼。还是举刚才的例子。zdydgshsj()，鬼才看得出来这是什么函数；zidingyidegeshishijianhanshu()，就算你看的懂，但你多次调用这个函数不觉得手抽筋么?customFormatTime()相对来说看到就会明白意思了，或者是customizeFormatTime()更正规些，函数写多了后，my_FormatTime()更有利于归类些。但是不管怎么样，总算能看明白含义。如果你还是嫌函数名过长的话，可以使用部分通用的英文缩写。比如表单相关的，frm可以作为前缀；数据库相关的，db可以做前缀；文件相关的，file可以做前缀。这样整体看起来就更美观和易用了。</p>
<p>但是重构也绝对不是一见到长代码就必须要拆了。如果是一片孤单的代码段，没有引用，没有公共模块，简单的一个逻辑，但是代码段比较长，就没有必要分了，因为它和别的模块，别的方法都没有交集，自然没有优化的必要了。<br>总的来说，重构的经验很多都来自于对编程的深入理解，理解越深，写的代码越优雅，执行的效率越高。</p>
<hr>
<p>啊，头一次写长文干货，一口气写了这么多字，好鸡冻(≧▽≦)/</p>
]]></content>
      
        <categories>
            
            <category> 架构设计 </category>
            
        </categories>
        
        
    </entry>
    
  
  
</search>
